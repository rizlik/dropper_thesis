\chapter{dROPper}

La prima parte di questo capitolo descrive l'architettura alla quale
si sta facendo riferimento per lo sviluppo di dropper mentre nella
seconda si farà un'analisi dettagliata dell'attuale implementazione.

\section{Architettura principale}

L'obiettivo di dropper è quello di generare, analizzando un file
oggetto eseguibile, una catena di gadget che iniettata nello stack
dell'immagine del processo associato a quell'eseguibile, consenta di
prenderne il controllo, eseguendo un comando arbitrario sulla
macchina. Lo strumento deve poter applicare tecniche note per eludere
misure di protezioni esistenti come la casualizzazione degli indirizzi
(\lstinline{ASRL}), l'isolamento delle pagine (\lstinline{NX}) o la
read-only relocation. Dropper analizza il binario utilizzando alcune
delle funzionalità del framework per l'analisi dei binari
\lstinline{BARF}. Il linguaggio utilizzato per la scrittura di dropper
è python. Dropper supporta file oggetto eseguibili di tipo ELF32 e
ELF64, architettura intel 8086 e amd 64, su piattaforme
GNU/Linux. Dropper, nella sua fase di analisi, estrapola dal file
binario i gadgets disponibili, per poi estrapolarne la semantica. Per
questi compiti dropper si avvale sia dell'emulazione dei gadget, sia
della loro modellizzazione in formule SMT, come descritto più in
dettaglio nelle prossime sezioni. Una volta estrapolata la semantica
dei gadget è possibile costruire piccole catene di uno o più gadget
che consentano di eseguire operazioni particolari (come modificare il
valore dello stack, chiamare una funzione, settare un registro,
scrivere in memoria, ecc). Dropper assembla queste piccole catene in
catene sempre più lunghe che eseguono operazioni più complesse e
articolate. La generazione di queste sequenze avviene,
nell'implementazione attuale, in maniera programmatica, cioè la
procedura per la sua costruzione è codificata in un algoritmo. È
interessante esplorare metodi di generazione di sequenze in maniera
dichiarativa, ad esempio utilizzando linguaggi di planning come
\lstinline{PDDL}\cite{pddl-97}. Una possibile modellizzazione è quella
in cui per ogni sequenza ``elementare'' vengono codificate le
precondizioni e gli effetti. Viene modellato lo stato del sistema
(memoria e registri) che si desidera ottenere dopo l'esecuzione di una
sequenza di gadget. Una volta codificato il problema in questi termini
si può chiedere ad un planner, come se fosse una sorta di oracolo, in
che sequenza collegare le varie azioni (cioè le varie sequenze
elementari di gadget) per ottenere quello stato. La rappresentazione
delle informazioni sulla semantica dei gadget è espressa in questo
modo in forma esplicita, e non più codificata in un algoritmo.

Dropper è composto da tre moduli principali:

\begin{itemize}

  \item dropper: È il modulo che si occupa di (a) leggere il binario,
    (b) coordinare le operazioni dei restanti moduli, (c) interagire
    con l'utente per ottenere informazioni aggiuntive sul binario e/o
    sullo scenario nel quale dev'essere prodotta la catena e (d)
    scegliere le tecniche da utilizzare per riuscire a generare la
    catena

  \item gadgetstools: È il modulo che si occupa dell'estrapolazione,
    dell'analisi, della scelta e dell'assemblaggio dei gadget da utilizzare nella
    composizione della catena e dei vari sui frammenti

  \item payloadchunk: È il modulo che si occupa di trasformare una
    sequenza ordinata di gadget in un payload vero e proprio da
    iniettare sullo stack, gestendo il posizionamento corretto degli
    indirizzi e dei valori utilizzati dai vari gadget

\end{itemize}

\subsection{Modulo dropper}

È il modulo che si occupa di leggere il file binario, interagire con
l'utente, scegliere le varie strategie da adottare e di coordinare le
azioni degli altri moduli. Il modulo legge il file e istanzia un
oggetto di tipo gadgets tools che si occuperà di estrapolare i gadgets
dal binario e analizzarli. Per il parsing delle strutture dati
presenti nell'elf dropper utilizza la libreria
\lstinline{pyelftools}\cite{pyelftools}. Combinando le informazioni
provenienti da queste sezioni dropper ricava la lista delle funzioni
che il file oggetto eseguibile utilizza e le relative entry nella
\emph{Procedure Linkage Table} (vedi TODORIF). La presenza di alcune
funzioni può semplificare molto la generazione della catena, di fatto
trasformandola in una serie di \emph{return-to-plt}. Dropper analizza
altre strutture chiave dell'ELF per individuare aree nella memoria
dell'immagine del processo dove è possibile scrivere. L'utente,
interagendo con il modulo, fornisce informazioni aggiuntive necessarie
alla generazione della catena e linee guida sulla strategia da
utilizzare. Tra le informazioni che il modulo non può ricavare
automaticamente troviamo:

\begin{itemize}
  \item La possibilità da parte dell'utente di controllare un file
    descriptor

  \item I file oggetto condivisi utilizzati dall'eseguibile sulla
    macchina dove si intende far eseguire la catena (per la
    ricavazione degli offset da utilizzare nelle tecniche di
    sovrascrizione della GOT Table vedi TODO)

  \item Eventuali caratteri che non possono comparire all'interno del
    payload

  \item Eventuali limiti sulla lunghezza dei payload

  \item Il comando da eseguire

\end{itemize}

Con tutte queste informazioni il modulo può quindi procedere nello
stabilire quale strategia utilizzare e richiedere al modulo
gadgetstools le sequenze di gadget necessarie. Lo schema principale,
con alcune varianti che analizzeremo in seguito, si può dividere in
due fasi: (a) preparare gli argomenti per eseguire una chiamata ad una
funzione di libreria che ci consenta di eseguire un comando arbitrario
e (b) eseguire quella funzione.

Alcune delle strategie che si possono utilizzare per raggiungere il
primo scopo insieme alle precondizioni necessarie sono elencate di
seguito:

\begin{itemize}

\item  Utilizzo della funzione \lstinline{read}

  Condizioni necessarie: 
  \begin{itemize}
   \item Controllo di un file descriptor da parte dell'utente
   \item Utilizzo da parte del file eseguibile della funzione
     \lstinline{read} o possibilità di richiamarla attraverso tecniche
     basate sulla ricavazione degli indirizzi partendo da indirizzi
     nella \lstinline{GOT} e offset relativi
  \end{itemize}

  Viene richiamata la funzione \lstinline{read}, impostando gli
  argomenti in modo che i dati letti dal file descriptor vengano
  scritti nell'area di memoria voluta

\item Utilizzo di gadget per la scrittura della memoria

  Condizioni necessarie:
  \begin{itemize}

    \item All'interno del file oggetto eseguibile deve essere presente
      almeno un gadget in grado di scrivere in memoria un valore
      arbitrario

    \item I valori da scrivere nella memoria non possono presentare
      caratteri che non possono essere presenti nel payload, essendo
      essi stessi scritti nel payload della catena generata

  \end{itemize}
  Solitamente una sequenza del genere consente di scrivere al massimo
  8 byte per volta in un'architettura 64bit (4 byte per volta su
  un'architettura a 32bit) e sono composte da almeno due gadget
  (almeno un gadget serve per settare i registri utilizzati del gadget
  che esegue la scrittura vera e propria). Questa tecnica tende quindi
  a generare catene piuttosto lunghe se la dimensione dei valori da
  scrivere in memoria è grande

\end{itemize}

Queste appena elencate le uniche due tecniche attualmente implementate,
strategie alternative potrebbero comprendere:

\begin{itemize}

\item Utilizzo delle funzioni \lstinline{strcpy} o \lstinline{memcpy}
  per copiare byte presenti in posizioni note all'interno
  dell'eseguibile nella posizione desiderata
  \cite{roglia:2009}. Questa tecnica, copiando verosimilmente solo un
  byte per volta tende anch'essa a generare payload abbastanza lunghi

\item Nel caso un bug renda possibile la conoscenza dell'indirizzo
  dello stack gli argomenti possono essere scritti direttamente nello
  stack

\end{itemize}

Una volta scritti gli argomenti per la funzione da richiamare in
memoria è necessario chiamare la funzione stessa. La funzione deve
permetterci di eseguire un comando arbitrario. All'interno della
\lstinline{libc} sono presenti due funzioni con queste
caratteristiche: \lstinline{execve} e \lstinline{system}. Un ritorno
diretto alla funzione solitamente non può avvenire, in quanto il
valore del suo indirizzo in memoria è casualizzato. Tuttavia, se una
funzione è utilizzata all'interno del programma, basterà ritornare
alla sua entry nella Program Linkage Table, che ha una posizione nota
e fissa all'interno della memoria dell'immagine del processo. Nel caso
invece che la funzione non venga utilizzata un'alternativa è quella di
adoperare tecniche per ricavare l'indirizzo della funzione partendo
dall'indirizzo di un'altra funzione della stessa libreria che invece
viene utilizzata dal programma. Questo funziona perché nonostante
l'indirizzo iniziale al quale una libreria viene caricata sia
casualizzato, gli offset tra le funzioni non cambiano. Alcune
considerazioni sull'utilizzo di questa tecnica:

\begin{itemize}

  \item Devono essere noti gli offset delle funzioni all'interno del
    file oggetto condiviso della libreria utilizzato sulla macchina
    bersaglio (anche se, variando in un range relativamente piccolo,
    non dovrebbe essere impossibile, se le condizioni lo consentono,
    montare un attacco di tipo forza bruta per ricavarli)

  \item il binario deve presentare una sequenza di gadgets che ci
    consenta di eseguire un'operazione di somma (o un'operazione che
    ci consenta si simulare una somma, come una sottrazione) tra un
    offset di tre/quattro byte e un'area di memoria arbitraria (l'area
    dove è memorizzato l'indirizzo della funzione usata come
    riferimento, solitamente nella GOT). Molto spesso però abbiamo
    gadget che ci consentono di addizionare solo un byte per
    volta. Questo è un problema perché in un'operazione di somma byte
    per byte dev'essere considerato un eventuale valore di riporto tra
    un byte e il successivo. Questo può essere risolto se il tipo di
    gadget trovato usa un'istruzione di tipo \lstinline{adc} (add with
    carry), controllando che tra gli effetti secondari degli altri
    gadgets non venga modificato il carry flag. In realtà anche non
    avendo a disposizione questo tipo di gadget, per via
    dell'allineamento in memoria, gli ultimi bit dell'indirizzo di una
    funzione non variano tra un'esecuzione e la successiva. Con
    questa parziale conoscenza del valore iniziale si può comunque
    creare una catena con un alta percentuale di successo come
    descritto in TODO

  \item Un tipo di attacco di questo tipo può essere mitigato se le
    rilocazioni vengono impostate come read-only. In questo caso
    infatti gli indirizzi delle funzioni vengono calcolati tutti al
    momento di caricamento del programma, e la GOT, una volta
    modificata opportunamente, viene resa non scrivibile. In questo
    caso è ancora possibile montare un attacco del genere, ma
    l'operazione aritmetica non può avvenire direttamente sulla got e
    non può essere utilizzato un ret-to-plt per saltare all'indirizzo
    calcolato. Bisogna cioè avere a disposizione i gadget necessari
    per leggere dalla memoria, effettuare l'operazione aritmetica e
    eseguire un jmp al nuovo indirizzo calcolato

\end{itemize}

È interessante notare come, anche se vi è una guida nelle operazioni
da seguire basata sulla strategia scelta, la sequenza di operazioni
che conducono allo stato del sistema desiderato sono molteplici. Ad
esempio l'operazione aritmetica per il calcolo dell'indirizzo della
funzione bersaglio potrebbe avvenire in memoria, oppure tra due
registri e poi salvata in memoria. Qui si notano i vantaggi che
potrebbe avere un approccio che modelli la situazione in un problema
di planning rispetto ad un approccio di tipo programmatico. Infatti,
con un approccio programmatico, tutte le combinazioni vanno codificate
nell'algoritmo, una procedura la cui completezza è più difficile da
dimostrare e che è molto più soggetta ad errori.

\subsection{Modulo gadgetstools}

Il modulo gadgets tools si occupa di ricavare i gadgets presenti nel
file oggetto eseguibile, di estrapolarne la semantica e della
creazione di sequenze di gadget che se eseguite assolvono funzioni
particolari (come scrivere in memoria, settare un registro,
ecc.). Questo modulo interagisce con payloadchunk per trasformare
sequenze ordinate di gadget in un payload vero e proprio da poter
iniettare sullo stack ed espone i metodi per la creazione delle catene
che vengono usati dal modulo dropper.

Per la ricerca dei gadget all'interno del file oggetto eseguibile
viene utilizzata la classe \lstinline{GadgetFinder} del framework
BARF, che implementa al suo interno l'algoritmo galileo\cite{roemer-12}. 

%TODO descrivere galileo ?
%TODO utilizzare il nostro ?

Una volta disponibile l'insieme dei gadget presenti nel file oggetto
eseguibile bisogna, per ognuno di essi, estrapolarne la semantica. Per
estrapolarne la semantica si intende estrapolare in maniera automatica
gli effetti che una serie di istruzioni hanno sul contesto il quale,
semplificando, è rappresentato dalla memoria e dai registri. Per
questo tipo di analisi si utilizzano due strumenti principali: la
simulazione e la traduzione delle istruzioni in formule
SMT. Un'analisi completa della semantica presenta alcuni limiti dovuti
alla difficoltà di una modellizzazione completa del sistema nonché
alla conoscenza parziale del contesto (memoria e registri) reale in
cui si troveranno ad essere eseguite le istruzioni. Ad esempio
utilizzando l'attuale traduzione delle istruzioni in formule SMT, è
difficile porre al risolutore domande che riguardino il numero di
letture effettuate, o domandare se un'area di memoria viene mai
letta. L'estrapolazione della semantica di un gadget avviene in tre
fasi: (a) emulazione e cataloghizzazione, (b) verifica e validazione e
(c) verifica degli effetti secondari.

\subsubsection{Emulazione e cataloghizzazione}
La classe \lstinline{GadgetClassifier} emula il gadget tenendo traccia
delle operazioni sui registri e sulla memoria. Con questi dati si
verifica se il gadget appartiene ad una o più categorie indicate in
\cite{schwartz-2011}. 
%TODO vanno elencate le categorie?  
Inoltre vengono identificati quali registri vengono utilizzati come
``operandi'' della funzione alla quale il gadget viene
associato. Basandosi su una simulazione e non su un effettiva analisi
semantica questa cataloghizzazione deve essere poi verificata. Per le
simulazioni vengono utilizzati dati concreti ma una simulazione
simbolica, funzionalità ancora non disponibile all'interno del
framework BARF, consentirebbe una cataloghizzazione più veloce e
accurata esplicitando le relazioni tra i valori che i registri hanno
all'inizio e alla fine della simulazione o tra i valori iniziali dei
registri e gli accessi alla memoria.

\subsubsection{Verifica e validazione}\label{s:verifica_validazione}
Si deve poi verificare che, anche se il gadget esegua la funzione
della categoria alla quale viene assegnato, possa essere utilizzato
per i valori di tutto il ``dominio'' di questa funzione, cioè che non
ci siano restrizioni sugli operandi del gadget. Per esempio, un gadget
catalogato come \lstinline{MemoryStore} ma che utilizzi lo stesso
registro come operando di destinazione e operando sorgente non può
essere utilizzato per scrivere in una locazione arbitraria di memoria
un valore arbitrario. Per questa verifica si scelgono casualmente gli
effetti che deve avere la funzione sul contesto. Ad esempio se stiamo
verificando un \lstinline{MemoryStore} si sceglie sia una locazione
casuale di memoria sia un valore casuale da scrivere in questa
locazione. Si traduce il gadget in formule SMT e si impone che il
contesto finale rifletta gli effetti, scelti casualmente, che la
nostra funzione deve avere. Nel nostro esempio si impone che la
locazione di memoria cambi al valore casuale scelto. Si chiede a
questo punto al risolutore se il sistema di formule ammette una
soluzione. Se il sistema non ammette soluzione il gadget può essere
scartato, in quanto non essendo usabile per quei valori perde la sua
generalità. Nel caso invece il sistema ammetta soluzione vengono
richiesti al risolutore i valori iniziali, all'interno del modello
trovato, dei registri che, secondo la cataloghizzazione al punto uno,
sono gli ``operandi'' della funzione. Si impongono poi al risolutore
nuovamente le formule SMT che rappresentano il gadget.  Questa volta
si impongono però come valori iniziali per i registri operandi i
valori ottenuti dalla prima verifica e, inoltre, che il valore finale
sia diverso da quello aspettato. La non soddisfacibilità di questa
formula ci dà la certezza che in tutti i modelli che soddisfano la
semantica del gadget, che hanno come valori iniziali dei registri
``operandi'' quelli ottenuti dalla prima verifica, lo stato finale del
contesto rispecchi i valori attesi. Questa verifica esclude che ci
siano effetti secondari che possono interferire con gli effetti della
nostra funzione. È da notare che queste proprietà sono verificate solo
per dei valori casuali e dovrebbero essere verificate per tutti i
valori. Questo non viene fatto sia per motivi di efficienza sia per
non includere quantificatori universali nelle formule, complicando di
molto il lavoro del risolutore e rischiando di ottenere formule non
decidibili. Questo problema può essere risolto ripetendo queste
verifiche al momento dell'utilizzo reale del gadget con i valori
concretamente utilizzati.

\subsubsection{Verifica degli effetti secondari}  

Il punto precedente ci assicura che un gadget non abbia effetti
secondari che interferiscano con gli effetti della nostra
funzione. Tuttavia è possibile che il gadget in esame abbia altri
effetti secondari che non lo rendano utilizzabile. Ad esempio se il
gadget legge da una locazione di memoria non leggibile causerà
l'arresto del programma. La modellizzazione in SMT utilizzata
attualmente nel framework BARF non consente di porre al risolutore
domande sul numero di letture in memoria o sulla lettura o meno di
un area di memoria. Per questo motivo per escludere effetti
secondari di questo tipo il gadget viene emulato con i valori di
ingresso ricavati al punto 2, e ci si assicura che non vengano lette
e scritte aree di memoria che non siano quelle relative alla
funzione propria del gadget o all'area dello stack.


La linea guida generale appena descritta va adattata alla tipologia di
gadget analizzata, per le implementazioni specifiche fare riferimento
alla seconda parte di questo capitolo. Inoltre per poter utilizzare un
gadget, i registri utilizzati come ``operandi'' devono essere
``controllabili'', cioè deve esistere una serie di gadget che consenta
di poter caricare valori arbitrari in questi registri. Per questo
prima di procedere alla verifica dei gadget si cercano all'interno
dell'eseguibile tutte le sequenze di gadget che ci permettono di
controllare registri. Se un gadget utilizza come operandi registri che
non sono ``controllabili'' questo viene scartato.

Inoltre è da notare come la verifica potrebbe avvenire in modo più
efficiente, utilizzando delle simulazioni mirate a scartare i gadget
che sicuramente non ci consentono di utilizzare valori arbitrari. In
questa fase dello sviluppo del progetto però l'efficienza non viene
considerata come prioritaria.  Durante queste le fasi di
classificazione e verifica vengono anche raccolte informazioni
aggiuntive sui gadget, come di come un gadget modifica il valore del
registro dello stack e la posizione dello stack dove inserire i valori
utilizzati dal gadget. Queste informazioni vengono utilizzate dal
modulo \lstinline{PayloadChunk} per costruire il payload vero e proprio.


Per le simulazioni viene utilizzata la classe \lstinline{ReilEmulator}
e la traduzione in formule smt avviene attraverso la classe
\lstinline{CodeAnalyzer}, entrambe del framework BARF.


\subsection{Payload Chunk}

Questo modulo si occupa di generare il payload vero e proprio partendo
dai gadget analizzati dal modulo gadgetstools. Questa classe è
strutturata in modo che i diversi chunk prodotti siano concatenabili,
e che la loro concatenazione dia a sua una volta un frammento
concatenabile. Questo ci consente di associare ad una data funzione un
payload e utilizzarlo in diverse parti del programma senza dover più
conoscerne i dettagli. Ci sono diverse cose da tenere in conto quando
si costruisce il payload partendo dai gadgets, quasi tutte legate alla
manipolazione dello stack da parte del gadget stesso:

\begin{itemize}

  \item posizioni dei valori utilizzati dal gadget in relazione alla
    valore puntato dallo stack al momento della sua esecuzione

  \item valore al quale punterà lo stack al momento dell'esecuzione
    dell'istruzione ret del gadget stesso. In base alla tipologia di
    gadget questo valore potrebbe non essere alla fine del payload
    relativo al gadget stesso
    
  \item valore finale dello stack dopo l'esecuzione del gadget

\end{itemize}

Le informazioni relative alle tre problematiche descritte sopra
vengono estrapolate dal gadgetstools. La procedura di generazione del
payload è specifica del tipo di gadget, i metodi
\lstinline{PayloadChunk.chain} e
\lstinline{PayloadChunk.get_general_chunk} sono invece generici,
prendono come argomento una lista di chunk e restituiscono
rispettivamente il payload dei chunk concatenati o un chunk che può
essere nuovamente concatenato e rappresenta la concatenazione dei
chunks in ingresso.


\section{Implementazione attuale}

\subsection{Dropper}

\subsubsection{Interazione con l'utente}

Attualmente dropper si interfaccia all'utente tramite alcune funzioni
della classe \lstinline{dropper}. Il costruttore di questa classe
riceve come argomento il percorso sul file system dove risiede il file
oggetto eseguibile da analizzare. Le operazioni di analisi vengono
avviate tramite la funzione \lstinline{analyze_all}. Una volta
analizzato si può richiamare la funzione
\lstinline{build_spawn_shell_payload} che si occupera di generare la
catena vera e propria. Anche se queste sono le uniche chiamate
essenziali l'utente ha a disposizione ulteriori funzioni:
\begin{itemize}

\item \lstinline{set_can_control_fd} setta il file descriptor
  controllato dall'utente (-1 se nessun file descriptor può essere
  controllato)

\item \lstinline{set_function_for_address_resolving} indica la
  funzione di riferimento da utilizzare nell'applicazione di tecniche
  che ricavino l'indirizzo di funzioni casualizzate in memoria
  partendo da valori nella GOT table. La funzione indicata dev'essere
  già stata richiamata almeno una volta al momento dell'esecuzione
  della catena

\item \lstinline{set_writeable_area} setta l'indirizzo di inizio
  dell'area di memoria dove effettuare operazioni di scrittura. Di
  default questo valore è settato all'indirizzo di caricamento in
  memoria della sezione \lstinline{.data}

\item \lstinline{set_cmd} setta il comando da eseguire sulla macchina
  bersaglio una volta che l'exploit ha avuto successo

\end{itemize}

Quando il file eseguibile è stato analizzato e le informazioni
necessarie impostate il metodo \lstinline{build_spawn_shell_payload}
cerca di generare una catena che avvii il comando impostato.

\subsubsection{Analisi degli import}

Se una funzione esterna viene utilizzata dal programma, anche se il
suo indirizzo reale viene casualizzato, sarà presente un elemento
relativo a quella funzione all'interno della procedure linkage
table. Questo elemento, ammesso che il binario non sia stato compilato
come indipendente dalla posizione in memoria (PIE), ha una posizione
nota. Possiamo quindi ritornare al suo indirizzo per emulare la
chiamata a quella funzione (return-to-plt). Nella GOT invece ogni
elemento inizialmente, e quindi anche staticamente nel file, contiene
l'indirizzo dell'istruzione successiva nell'elemento della PLT
relativo alla stessa funzione. Per ogni funzione la rilocazione
associata, nella sezione \lstinline{.rel.plt}, contiene nel campo
\lstinline{r_offset} l'indirizzo dell'elemento nella GOT table. A
partire da quest'ultimo, per le considerazioni appena fatte, può
essere ricavato l'indirizzo della entry nella PLT. Gli indirizzi del
relativo elemento della GOT e di quello nella PLT vengono ricavati per
ogni funzione utilizzata dal file oggetto eseguibile nel metodo
\lstinline{get_imports}.

\subsubsection{Costruzione della catena}

Attualmente il modulo dropper per prima cosa cerca di scrivere in
un'area di memoria scrivibile i dati ai quali punteranno gli argomenti
dell'invocazione della funzione \lstinline{execve}. Nel caso
quest'area di memoria non viene specificata dall'utente viene
utilizzato l'indirizzo di caricamento in memoria della sezione
\lstinline{.data}. Gli argomenti e i dati veri e propri vengono creati
dal modulo partendo dal comando che si è deciso di eseguire sulla
macchina (nella funzione \lstinline{payload_execve_args}). Se si può
controllare un file descriptor e \lstinline{read} è presente
nell'insieme delle funzioni utilizzate dal programma allora dropper
crea una catena che ritorni all'elemento all'interno della PLT
relativo a \lstinline{read} e fa in modo che vengano letti, dal file
descriptor indicato, una quantità di dati pari alla dimensione dei
dati da scrivere e che essi vengano scritti nell'area di memoria
scelta come area scrivibile. Per far questo viene utilizzato il metodo
\lstinline{get_ret_func_chunk} del modulo gadgets tool il quale ci
consente di creare una catena che richiami una funzione di cui si
conosce l'indirizzo. È compito poi dell'utente fare in modo che al
momento della chiamata di questa funzione il file descriptor indicato
si trovi nello stato giusto a restituire i valori calcolati dal
modulo. I valori da fornire nel file descriptor vengono forniti
all'utente nel parametro \lstinline{fd_payload} di dropper.
%%TODO
Esempio?

Attualmente è implementata una seconda strategia nel caso non sia
presente la funzione \lstinline{read} e/o non si controlli nessun file
descriptor. Essa consiste nell'utilizzare una serie di gadget che
possano spostare valori dallo stack in una locazione di memoria
arbitraria.  Per costruire una catena del genere si chiama la funzione
\lstinline{build_memory_write} del modulo gadgets tools che prende
come argomenti l'indirizzo della memoria dove scrivere e i dati da
scrivere. Solitamente, come vedremo in \ref{sec:memorystore}, le
catene generate in questo modo tendono ad essere piuttosto lunghe.

%%TODO inserire strategie non implementate?

Per quanto riguarda la seconda fase, la chiamata della funzione, sono
state implementate solo due strategie. La prima nel caso
\lstinline{execve} sia presente all'interno delle funzioni utilizzate
dal programma. In questo caso la generazione della parte restante
della catena è banale e, come visto nel paragrafo precedente, viene
costruita dalla funzione \lstinline{get_ret_func_chunk} del modulo
gagdettools. Più interessante è il caso in cui il file oggetto
eseguibile non utilizzi questa funzione. Una strategia che è possibile
adottare in questo caso si basa sul calcolo dell'indirizzo della
funzione voluta partendo da una funzione utilizzata dal programma, il
cui indirizzo viene ricavato dal relativo elemento nella GOT table. La
funzione dev'essere già stata chiamata almeno una volta, questo fa si
che nella GOT table sia presente l'indirizzo reale e non l'indirizzo
del relativo elemento all'interno della PLT. L'indirizzo può essere
sia calcolato in un registro o in una zona di memoria per poi
sfruttare una tipologia di gadget che ci permetta di ``saltare''
all'indirizzo calcolato (\emph{got dereferencing}). È anche possibile,
se l'eseguibile non è compilato con RORELOC, modificare il valore
della GOT in loco, aggiungendo l'offset necessario (\emph{got
  patching}). Attualmente è implementata solo la seconda strategia. Il
modulo gadgets tools espone il metodo \lstinline{build_memory_write} che
si occupa dei dettagli implementativi di questo tipo di catena. Viene
chiamato da dropper con i seguenti parametri:

\begin{itemize}
  \item l'indirizzo di memoria dove eseguire la somma: l'indirizzo
    dell'elemento della GOT da ``patchare''

  \item il valore da aggiungere: l'offset relativo tra la funzione
    utilizzata come base e quella voluta

  \item il valore di base: l'offset che la funzione di base ha
    all'interno del file oggetto condiviso della libreria. Come
    vedremo questo rende possibile utilizzare la tecnica anche quando
    le tipologie di gadget disponibili non sono ideali al prezzo di
    sacrificare un'affidabilità del 100\% (vedi
    sez. \ref{sec:arithmeticstore})

\end{itemize}

La classe inoltre contiene alcuni metodi per il salvataggio dei dati
relativi ai gadgets su disco, questo perché l'analisi di eseguibili
molto grandi può durare diversi minuti. Al loro interno questi metodi
utilizzano la libreria \lstinline{pickle} per la serializzazione degli
oggetti.

\subsection{GadgetsTools}

Questo modulo estrapola e cataloga i gadget presenti nel binario in
esame ed espone i metodi di creazione delle catene per l'esecuzione di
diverse funzioni. Le catene vengono costruite arrangiando i gadget
disponibili e collaborando con il modulo payloadchunk che si occupa
della generazione del payload vero e proprio. Fondamentale per poter
utilizzare un gadget è poter controllare i registri coinvolti nelle
sue operazioni, per questo motivo la prima analisi che viene condotta
una volta ottenuta la lista dei gadget è la selezione di quelli che ci
consentono di controllare i registri. La ricerca dei gadget viene
effettuata in tutte le sezioni che vengono caricate in memoria
(discriminate dal tipo \lstinline{SHT_PROGBITS}) e marcate come
eseguibili.

\subsubsection{Selezione dei gadget per l'impostazione dei registri}

La logica e le strutture dati utilizzate per la selezione e la
gestione dei gadget utilizzati per l'impostazione dei registri è
contenuta nella classe \lstinline{RegSet}. Il metodo
\lstinline{_analyze_gadget} riceve come argomento in ingresso un
gadget e, nel caso esso possa essere utilizzato per l'impostazione di
registri, viene aggiunto nelle strutture dati interne alla classe. La
classe espone il metodo \lstinline{get_chunk} che ritorna una catena
che imposta i registri in modo da riflettere le coppie registro/valore
del dizionario preso come argomento. Attualmente solo gadget che
contengono istruzioni di tipo \lstinline{pop reg} vengono considerati
come potenziali candidati per l'impostazione di registri. L'analisi
avviene tramite la simulazione istruzione per istruzione. Se
l'istruzione attuale è di tipo \lstinline{pop reg} allora si memorizza
il nome del registro e l'offset tra il valore attuale dello stack e
quello all'inizio della simulazione. Questo ci consente di conoscere
dove posizionare il valore da impostare nel registro al momento della
generazione del payload. Durante la simulazione si controlla anche che
le istruzioni che non sono del tipo \lstinline{pop reg} non eseguano
operazioni di lettura o scrittura sulla memoria. Questo ci consente di
scartare già in questa fase i gadget che presentano effetti
secondari. Alla fine della funzione abbiamo la lista dei registri che
il gadget può impostare con i relativi offset dello stack. La funzione
\lstinline{get_chunk} invece restituisce una catena che consente di
impostare l'insieme dei registri che riceve in ingresso. Dato che un
gadget potrebbe impostare più di un registro, la scelta dei gadget che
andranno a comporre questa catena è riducibile ad un problema di
\emph{set covering}. È preferibile che il payload generato dalla
catena sia il più piccolo possibile. La lunghezza della catena è
influenzata sia dal numero di gadget utilizzati, sia dal padding che è
necessario inserire nell'utilizzo di ogni gadget per via delle
operazioni che esso effettua sul registro dello stack. Attualmente per
trovare la catena viene utilizzato un algoritmo greedy che scorre i
registri da ``coprire'' e, se il registro non è già coperto da un
gadget inserito nella catena, sceglie il gadget che lo copre e che
necessita del minor padding possibile. Se l'aggiunta di un gadget ne
rende superfluo uno già presente nei candidati quest'ultimo viene
rimosso. La soluzione trovata con quest'algoritmo non è ottima.

\subsubsection{Selezione dei gadget per la scrittura in memoria}
\label{sec:memorystore}

La logica e le strutture dati per gestire i gadget che ci consentono
di scrivere in memoria si trovano nella classe
\lstinline{MemoryStore}.  Durante la prima classificazione la classe
\lstinline{GadgetClassifier} del framework BARF verifica se a seguito
di alcune simulazioni un valore presente in un registro (denominato
sorgente) viene scritto in una locazione di memoria il cui indirizzo
corrisponde al valore di un registro (denominato destinazione) sommato
ad un eventuale offset. Ogni volta che questa condizione viene
verificata il gadget viene aggiunto alla categoria StoreMemory. È da
notare che la condizione di cui sopra potrebbe verificarsi per più
coppie di registri nello stesso gadget, per ognuna di queste viene
creato un oggetto gadget di tipo StoreMemory e aggiunto alla
categoria. La classe parte da questi gadget per procedere alla fase di
verifica e validazione. Innanzitutto se il registro di destinazione è
il registro dello stack il gadget viene scartato. Questo fa in modo
che non vengano presi in considerazione i gadget con istruzioni tipo
\lstinline{push reg}. Questi gadget infatti, solitamente non
consentono di scrivere in una regione arbitraria della memoria, oltre
a complicare la gestione dello schema dello stack. Dopo di che vengono
scartati anche i gadget che hanno come registro di destinazione rip e
eip. Infatti essendo questo registro fisso rispetto all'istruzione che
lo esegue neanche questi gadget ci consentono di scrivere in una
posizione arbitraria di memoria. Dopo di che si procede seguendo le
linee guida descritte in \ref{s:verifica_validazione}: il gadget
viene scartato se non si possono controllare i registri sorgente e
destinazione, si verifica e valida la generalità e ci si assicura che
il gadget non presenti effetti secondari. I valori scelti casualmente
per la verifica e la validazione sono la locazione di memoria e il
valore da scrivere. Nella verifica degli effetti secondari si
controlla che non ci siano scritture al di fuori della locazione
scelta e dello stack. Il metodo \lstinline{get_chunk} invece prende
come argomenti un indirizzo in memoria e dei valori e restituisce una
catena che scrive i valori in memoria partendo da quell'indirizzo. Il
metodo sceglie uno dei gadget disponibili e calcola quante iterazioni
sono necessarie per la scrittura dei valori. Per ogni iterazione poi
utilizza il risolutore SMT per ottenere i valori dei registri sorgente
e destinazione corretti. Sempre per ogni iterazione, si utilizza la
classe \lstinline{regset} per ottenere una catena che setti i registri
a quei valori, e la si concatena a sua volta al gadget che si sta
utilizzando per scrivere in memoria. Viene restituita la
concatenazione delle catene create per ogni iterazione, che
verosimilmente scriverà in memoria, partendo dall'indirizzo indicato
i valori in ingresso.

\subsubsection{Selezione dei gadget per la operazioni aritmetiche in
  memoria}
\label{sec:arithmeticstore}

La logica e le strutture dati per la gestione dei gadget che ci
consentono di scrivere in memoria risiedono nella classe
\lstinline{aritmeticmemorystore}. Anche in questo caso si parte dai
gadget classificati dal framework BARF, ma appartenenti, per
l'appunto, alla categoria Arithmetic Memory Store. Un gadget viene
inserito in questa categoria se, dopo alcune simulazioni del gadget,
una locazione di memoria viene modificata e come valore finale
riflette il risultato di un'operazione aritmetica binaria tra il
valore precedente di quella locazione e il valore iniziale contenuto
in un registro. Inoltre si individua un registro che potrebbe essere
usato dal gadget come indirizzo della locazione di memoria (insieme ad
un eventuale offset). Dato che la simulazione viene ripetuta più volte
i falsi positivi vengono ridotti. È possibile che un gadget esibisca
il comportamento di cui sopra più di una volta, anche in questo caso
vengono creati diversi oggetti di tipo Arithmetic Memory
Store. L'analisi di questi gadget procede, come anche nella categoria
precedente, sulla falsa riga della procedura indicata in
\ref{s:verifica_validazione}. Tuttavia un'attenzione particolare va
posta nell'analisi dei gadget che utilizzano un'operazione di
addizione che considerano il valore di riporto (ad esempio adc su
intel). Questi gadget possono rilevarsi molto utili. Spesso infatti
sono disponibili solo gadget aritmetici che ci consentono di
aggiungere un byte per volta. Effettuare un'operazione di got patching
(vedi sez. \ref{sec:got_patching}) un byte per volta senza considerare
i valori di riporto tra un byte e il successivo può portare ad un
risultato errato dell'operazione che si sta effettuando. Per poter
permettere la cataloghizzazione di questo tipo di gadget, si è dovuto
applicare una piccola patch al framework per permetterci di poter
controllare in qualche modo il contesto dei registri che utilizza
durante le simulazioni per la classificazione. Infatti il
classificatore, nella traduzione in reil, considera il flag carry del
registro dei flag come un registro a se stante di 16bit che viene
aggiunto al risultato dell'operazione. Dato che questo valore è
impostato casualmente i risultati delle simulazioni vengono
falsati. La nostra modifica ci permette di settare un valore
arbitrario per alcuni registri nelle simulazione, quindi
inizializzeremo il ``registro'' con il quale è rappresentato il carry
flag a zero. Questo viene anche imposto nelle verifiche che utilizzano
un risolutore SMT. In più viene aggiunta una seconda coppia di
modellazioni SMT con le quali si verifica se il gadget in esame
utilizza il carry flag nell'operazione e se a seguito di un'operazione
che sicuramente generi un valore di riporto, il carry flag al termine
del gadget abbia valore uno. Questo ci dà la certezza rispettivamente
che il gadget va ad utilizzare il carry flag nelle operazioni di
addizione e che le operazioni successive all'interno del gadget non
vadano ad influenzare il carry flag. Come detto sopra, per costruire
una catena che ci consenta di aggiungere un valore arbitrario ad una
locazione di memoria arbitraria, bisogna avere a disposizione o gadget
aritmetici la cui dimensione dell'operazione sia di almeno un byte più
grande dell'addendo o un gadget che, per l'appunto, consenta di
eseguire operazioni utilizzando i valori di ritorno. In questo secondo
caso però bisogna anche concatenare, se è disponibile, un gadget che
abbia come effetto quello di azzerare il carry flag, da inserire prima
dell'operazione. La logica per la ricerca di questo tipo di gadget è
presente nella classe \lstinline{ClearCarryFlag}. È da notare che se
questo tipo di gadget non fosse presente la catena generata potrebbe
non avere l'esito sperato, tuttavia è presumibile che in molti tipi di
exploit il carry flag abbia sempre lo stesso valore all'inizio
dell'esecuzione della catena. La sottrazione quindi di un'unità al
primo byte dell'offset dovrebbe essere sufficiente per generare una
catena corretta. Se non sono disponibili né un un gadget che consenta
di aggiungere abbastanza bytes per volta né un gadget che effettua
operazioni considerando il valore di riporto è tuttavia possibile
generare una catena con alte probabilità di successo. Infatti
l'indirizzo di memoria nel quale viene caricato il file oggetto
condiviso della libreria, nonostante sia casualizzato, dev'essere
allineato in memoria al valore specificato nel parametro
\lstinline{p_align} all'interno del program header. Questo comporta
che un certo numero di bits meno significativi dell'indirizzo di una
funzione non cambino da un'esecuzione all'altra. Solitamente sono i
21bits meno significativi, e l'offset tra due funzioni nella libc
solitamente è tre byte. Questo fa si che si può calcolare il valore di
riporto per i primi due byte. Solo il valore di riporto dell'ultimo
byte (di cui conosciamo solo la parte meno significativa) risulterebbe
casuale, facendo si che si possano generare catene con probabilità di
successo pari almeno al 50\%.


È da notare che nell'implementazione attuale manca ancora
l'implementazione della logica per la ricerca e la verifica di
importanti categorie di gadget (come Jump, MemoryLoad, MoveRegister o
Arithmetic). L'implementazione di queste categorie dovrebbe consentire
la generazione di catene in condizioni più articolate o quando le
categorie di gadget attualmente implementate non sono disponibili.

\subsection{PayloadChunks}

Questo modulo si occupa di generare a partire da una lista ordinata di
uno o più gadgets un array binario di dati da iniettare nello stack
del file oggetto eseguibile esaminato. La preparazione del payload
varia rispetto al gadget per il quale si sta creando il chunk e può
consistere nel solo indirizzo del gadget, o in schemi più complicati
come indirizzi di funzioni più relativi argomenti o a valori da
trasferire dalla stack ai registri. Ogni classe che si occupa della
generazione di un particolare tipo di chunk ha le informazioni
necessarie per permettere al chunk stesso di essere concatenato ad
altri chunk per generarne un altro, anch'esso a sua volta
concatenabile, che rappresenti i chunk di partenza. Per permettere
questa concatenazione ogni chunk deve presentare le seguenti
informazioni:

%3201899105

\begin{itemize}

\item L'indirizzo che deve trovarsi sullo stack al momento
  dell'esecuzione dell'istruzione ret del gadget precedente 

\item In quale posizione del payload inserire l'indirizzo del gadget
  successivo

\item La dimensione degli indirizzi nell'architettura considerata

\end{itemize}


Le classi che modellano i vari tipi di chunk hanno tutti un metodo,
\lstinline{get_payload}, che restituisce il payload del chunk di
riferimento (escluso l'indirizzo del gadget stesso). Quando due gadget
vengono concatenati per generare un chunk più generico (nel metodo
\lstinline{PayloadChunk.get_general_chunk}), l'indirizzo di ogni chunk
viene inserito nella posizione indicata dal chunk precedente. Nel
momento che si richiede il payload vero e proprio (attraverso il
metodo \lstinline{PayloadChunk.chain}) oltre all'operazione di
concatenazione viene anche inserito l'indirizzo del primo gadget
all'inizio del payload.


 %TODO spostare in implementazione attuale?
%% Questo avviene emulando tutti i gadgets, e nello stesso momento
%% parsando le istruzioni. Si tiene traccia, istruzione per istruzione,
%% di quanto si sia modificato il valore dello stack. Nel caso si
%% incontri un'istruzione del tipo pop reg, viene associato a quel
%% registro l'attuale differenza tra il valore dello stack relativamente
%% all'istruzione corrente e quello all'inizio della simulazione. A
%% questo punto abbiamo per ogni gadget una lista di registri e di offset
%% rispetto ai quali inserire il valore nello stack per inserire un
%% valore arbitrario nel relativo registro. Inoltre tramite la
%% simulazione si deduce la differenza tra il valore dello stack
%% all'inizio del gadget e quello alla fine. Questo valore dovrà essere
%% noto solitamente per tutti i gadget in quando ci permette di far
%% trovare al posto giusto l'indirizzo di ritorno del gadget lo che
%% succede nella catena. Nel caso il gadget non contenga nessuna
%% istruzione del tipo pop reg, questo viene scartato. Inoltre nella
%% simulazione viene tenuta traccia degli indirizzi di memoria letti e/o
%% scritti. Nel caso vi sia scrittura nella memoria o lettura da una zona
%% di memoria non riconducibile all'area relativa allo stack il gadget
%% viene scartato. 


%% La semantica potrebbe essere poi verificata trasformando le istruzioni
%% del gadget in formule smt, verifcando che la semantica e i valori
%% estratti non siano dipendendi dai valori di ingresso, e quindi
%% relativi solo alla simulazione effettuata. In pspecial modo è possibile
%% che il valore dello stack venga modificato utilizzando un valore di un
%% registro. TODO




%% La catena dei gadget generata da dROPper deve, una volta
%% iniettata nello stack del processo in esecuzione, poter eseguire un
%% comando arbitrario sulla macchina in cui è in corso l'esecuzione del
%% programma. La catena generata deve funzionare anche nel caso che gli
%% indirizzi in memoria delle librerie utilizzate da programma siano
%% stati casualizzati (ASRL) e che nè lo stack nè alcuna regione
%% scrivibile sia eseguibile (NX). La strategia da utilizzare dipende dal
%% binario utilizzato e da che tipo di controllo abbiamo sui dati di
%% ingresso del programma. In ogni caso lo schema principale, con alcune
%% varianti che analizzeremo in seguito, si può dividere in due fasi
%% principali: (a) preparare gli argomenti per eseguire una chiamata ad
%% una funzione di libreria che ci consenta di eseguire un comando
%% arbitrario e (b) eseguire quella funzione al fine si eseguire il
%% comando voluto. Le strategie per arrivare alla concretizzazione di
%% queste due fasi dipendono dal file oggetto eseguibile che si sta
%% analizzando che può presentare scenari relativamente semplici, in cui
%% ad esempio il programma utilizza già le chiamate a funzioni
%% necessarie, permettendoci di utilizzare \emph{return-to-plt} sia a
%% scenari più complessi, dove l'indirizzo delle funzioni necessarie
%% viene ottenuto durante l'esecuzione partendo dagli indirizzi presenti
%% nella Global Offset Table.

%% Dropper inizia ad analizzare il binario affidandosi al framework BARF
%% per l'estrazione e una prima cataloghizzazione dei gadget. Le
%% categorie in cui il framework suddivide i gadget sono quelle indicate
%% in[]:

%% \begin{itemize}


%% \end{itemize}

%% \section{Implementazione attuale}

%% \subsection{dropper}

%% Dropper legge dal file le sezioni
%% \lstinline{.rel.plt}, \lstinline{.dynsym},\lstinline{.got} e
%% \lstinline{.got.plt}.

%%  analizza
%% poi la sezione ``.data'', se non viene specificato diversamente
%% dall'utente verrà utilizzato l'indirizzo in memoria di questa sezione
%% come area di memoria dove poter scrivere dati. Questo ci permette di
%% avere una posizione nota (l'indirizzo in memoria di ``.data.'' non è
%% casualizzato) dove poter scvrivere gli argomenti delle funzioni che
%% andremo ad utilizzare



%% TODO :
%% # verificare i gadget di tipo regset
%% # trovare i tipi regset e modellare la memoria (utilizzando > e < per
%% segnare le aree di memoria scrivibili e le aree di memoria leggibili)


%% Una prima
%% possibiltà è quella di utilizzare delle sequenze di gadget che ci
%% consentato di modificare un valore in memoria aggiungendoci un
%% addendo. In questo modo è possibile addizionare l'offset noto nell got
%% table, e successivamente fare un ret-to-plt. Il valore presente nella
%% got table adesso punterà alla funzione voluta. Per utilizzare questa
%% tecnica devono essere soddisfatte le seguenti precondizioni:
