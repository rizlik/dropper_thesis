\chapter{Exploit}

L'utilizzo di varie tecniche di protezione hanno reso sempre più
difficile lo sfruttamento di errori nell'esecuzione di un programma al
fine di prenderne il controllo. Questo capitolo introduce brevemente
alcune di queste tecniche e analizza con quali metodi è possibile
eluderle. Anche se alcuni concetti sono indipendenti dall'architettura
e dal sistema operativo questo capitolo tratterà esclusivamente di come
queste tecniche sono implementate in ambiente GNU/Linux, su
architettura 8086 e amd64. Nella prima parte di questo capitolo si
parlerà brevemente dei principali meccanismi con i quali il sistema
operativo, partendo dalle informazioni presenti all'interno di un file
oggetto eseguibile, crea una rappresentazione dinamica del programma,
detta \emph{immagine del processo}. Una volta creata l'immagine del
processo il controllo viene ceduto al programma che inizia la sua
esecuzione. La prossima sezione si soffermerà solo sulle parti
rilevanti per il lavoro svolto.

\section{ELF, loading}

ELF (Executable and Linkable Format) viene utilizzato per 
rappresentare tre tipi di file oggetto:

\begin{itemize}
  \item \emph{file oggetto rilocabile}: contiene dati e codice che
    vengono collegati ad altri file oggetto al fine di ottenere un
    \emph{file oggetto eseguibile} o un \emph{file oggetto condiviso}

  \item \emph{file oggetto eseguibile}: è la rappresentazione statica
    di un programma che può essere eseguito, questo file ha le
    informazioni necessarie affinché il sistema operativo crei la sua
    immagine di processo

  \item \emph{file oggetto condiviso} che contiene codice e dati
    adatti per essere collegati (nel processo di linking) in due
    contesti differenti. Può essere infatti utilizzato sia in fase di
    building insieme ad altri file oggetto rilocabile o file oggetto
    condivisi (\emph{linking statico}) per creare altri file oggetto,
    oppure può essere collegato in fase di creazione dell'immagine del
    processo di un file oggetto eseguibile (\emph{linking dinamico}).

\end{itemize}

Il formato ELF può contenere sia le informazioni necessarie per
processi relativi alla fase di creazione di diversi file oggetto a
partire da file sorgente (in particolare informazioni necessarie per
la fase di linking), sia relativamente allo scopo della creazione
dell'immagine di un processo a partire da un file oggetto
eseguibile. Anche le strutture dati all'interno dell'ELF responsabili
di questi due ``punti di vista'' sono differenti, e, a seconda della
tipologia del file oggetto alcune delle strutture dati possono non
essere presenti. Essendo più rilevante ai fini del nostro lavoro ci
concentreremo principalmente sulle strutture dati rilevanti nelle
operazioni di creazione dell'immagine del processo e nelle procedure
di dynamic linking, ovvero nel processo con il quale si rendono
fruibili all'eseguibile i metodi esposti da una libreria condivisa a
tempo di esecuzione.

\subsection{Program header table}

L'ELF header (che è l'unica struttura dati che ha una posizione fissa
all'interno del file) funge da una sorta di mappa, e ci consente di
localizzare tutte le altre strutture dati presenti nel file.

Tra queste vi è la \emph{Program header table}. La program header
table è un array di strutture, ognuna delle quali contiene o
informazioni su come costruire un segmento della memoria dell'immagine
di un processo o informazioni per la preparazione dell'immagine
stessa. Una entry all'interno della program header table (su
un'architettura a 32bit) è rappresentata dalla seguente struttura C:

\begin{lstlisting}[caption=program header table entry]
typedef struct {
  uint32_t   p_type;
  Elf32_Off  p_offset;
  Elf32_Addr p_vaddr;
  Elf32_Addr p_paddr;
  uint32_t   p_filesz;
  uint32_t   p_memsz;
  uint32_t   p_flags;
  uint32_t   p_align;
} Elf32_Phdr;
\end{lstlisting}

La struttura relativa ad un'architettura a 64bit è pressoché identica,
l'unica differenza sta nella posizione degli attributi.  L'attributo
\lstinline{ptype} indica il tipo di entry. Per il nostro scopo ci
limiteremo a descrivere le entry di tipo \lstinline{PT_LOAD},
\lstinline{PT_INTERPETER} e \lstinline{PT_DYNAMIC}. Le entry di tipo
\lstinline{PT_LOAD} rappresentano informazioni su un segmento da
caricare in memoria. Il campo \lstinline{p_offset} e
\lstinline{p_filesz} indicano rispettivamente l'offset e la sua
grandezza all'interno del file. \lstinline{p_vaddr} e
\lstinline{p_memsz} invece indicano rispettivamente il base address
nel quale caricare in memoria il segmento e la dimensione che avrà in
memoria (che potrebbe essere più grande rispetto a quella sul
file). \lstinline{p_flags} è molto rilevante per il nostro lavoro e
indica con quali flags il segmento andrà ad essere caricato in memoria
ovvero se il segmento sarà o meno scrivibile, leggibile e/o
eseguibile. Tuttavia nel caso il segmento contenga codice compilato
affinché risulti indipendente dal indirizzo base nel quale risiede in
memoria, il campo \lstinline{p_vaddr} potrebbe essere nullo e la
posizione del segmento in memoria potrebbe essere casualizzata.

La voce all'interno della program header table con il tipo
\lstinline{PT_INTERP} invece contiene una stringa che rappresenta il
percorso di un file oggetto eseguibile o condiviso all'interno del
filesystem, detto interprete. Il sistema operativo crea l'immagine del
processo dell'interprete, dandogli il controllo. Sarà compito poi
dell'interprete creare l'immagine del processo necessaria
all'esecuzione dell'eseguibile. Affinché questo possa accadere
l'interprete avrà accesso alle informazioni presenti nel file
principale. Normalmente l'interprete è costituito da codice
indipendente dalla posizione nella quale viene caricato, che viene
casualizzata evitando conflitti tra gli spazi di memoria utilizzati
dall'eseguibile principale e quelli dell'interprete stesso.

Quando viene creato del codice oggetto che utilizza delle librerie
dinamiche, il linker aggiunge alla program header table un elemento di
tipo \lstinline{PT_INTERPRETER} con impostato come interprete il
\emph{dynamic linker}, che si occupa di trovare le librerie necessarie
all'eseguibile, caricarle in memoria, caricare in memoria i segmenti
dell'eseguibile, risolvere le relocation verso i simboli delle
librerie, e ridare poi controllo all'eseguibile stesso. Come vedremo
la risoluzione di un simbolo potrebbe essere rimandata fin quando non
sia realmente necessario. A supporto di questi processi troviamo
alcune strutture dati, anch'esse aggiunte al file oggetto eseguibile
durante la fase di linking. Queste strutture risiedono all'interno di
segmenti che vengono caricati in memoria, e sono quindi disponibili
durante l'esecuzione del programma. Informazioni su dove trovare
queste strutture dati possono essere ricavati attraverso un'altra
struttura dati del file ELF, la \emph{Section header table}, che è un
array di strutture che descrivono, per l'appunto, le parti che
compongono il file. Tuttavia, anche se anche nel nostro lavoro di tesi
le section vengono utilizzate per ottenere informazioni sul binario
esaminato, è da notare che esse non sono necessarie per un file
oggetto di tipo eseguibile. Un file oggetto infatti può essere
caricato esclusivamente con le informazioni presenti nella program
header table (lo strumento sstrip\cite{sstrip} elimina appunto le
sezioni da un file eseguibile). Tuttavia è conveniente per scopi
illustrativi riferirsi alle strutture dati relative al processo di
dynamic linking esaminandone le rispettive sezioni:

\begin{itemize}

  \item Una sezione \lstinline{.dynamic} che contiene gli indirizzi di
    altre strutture necessarie al processo di dynamic linking e la
    lista delle librerie necessarie all'esecuzione del file oggetto
    eseguibile

  \item Una sezione \lstinline{.hash} che contiene una tabella dei
    simboli

  \item Le sezioni \lstinline{.got} e \lstinline{.plt} contengono
    rispettivamente due tabelle: \emph{la global offset table} e
    \emph{la procedure linkage table}. Nelle sezioni successive
    vedremo come queste due strutture dati vengono utilizzate dal
    dynamic linker per risolvere i simboli e le chiamate a funzioni
    presenti nelle librerie dinamiche

\end{itemize}

\subsection{Global Offset Table e Procedure Linkage Table}

Un programma che sia indipendente dalla posizione in cui viene
caricato in memoria non può contenere al suo interno indirizzi
assoluti. Le global offset table (\lstinline{GOT}) contengono
indirizzi assoluti in un'area di memoria privata destinata ai dati,
non compromettendo quindi il fatto che il codice sia indipendente
dalla posizione (e quindi che sia condivisibile da più immagini di
processo, come nel caso di una libreria dinamica). Il linker, una
volta creata l'immagine di un processo, processa tutte le rilocazioni
(strutture dati che contengono informazioni per la risoluzione dei
simboli) di tipo \lstinline{R_386_GLOB_DAT} e per ognuna di esse
calcola l'indirizzo assoluto. Il linker conoscendo l'indirizzo di
tutti i file oggetto caricati in memoria ha tutte le informazioni
necessarie per calcolare il valore di questi indirizzi. Una volta
calcolati il linker inserisce i valori assoluti nei rispettivi
elementi della \lstinline{GOT}, permettendo all'eseguibile di
accedervi attraverso posizioni relative.

A noi interessa principalmente come la \lstinline{GOT} è coinvolti nel
momento in cui un file oggetto eseguibile esegue una chiamata ad una
funzione di una libreria dinamica, processo in cui è coinvolta anche
una seconda tabella, la procedure linkage table (\lstinline{PLT}).

La procedure linkage table redireziona chiamate a funzioni che non
siano dipendenti dalla posizione a valori assoluti non conosciuti al
momento della fase di linking di un eseguibile. Infatti in fase di
building di un eseguibile il linker fa in modo che le chiamate a
queste funzioni vengano direzionate a elementi della
\lstinline{PLT}. Anche se la \lstinline{PLT} risiede nel segmento di
memoria destinato a contenere il codice di un eseguibile, utilizza
valori nella global offset table, non compromettendo così né
l'indipendenza dalla posizione ne la condivisibilità del codice. È
compito del dynamic linker calcolare i valori degli indirizzi della
funzione ei impostarli nei relativi elementi della
\lstinline{GOT}. Nella restante parte di questa sezione andremo a
descrivere come il dynamic linker utilizza queste due tabelle per
risolvere gli indirizzi. È da notare che faremo riferimento
all'implementazione su un'architettura a 32bit. Tuttavia il concetto
principale resta pressoché invariato anche per un'architettura a
64bit. La \lstinline{PLT} è strutturata come nel listato
\ref{cod:plt}.

\begin{lstlisting}[caption=Procedure linkage table, label=cod:plt]
.PLT0:
    pushl   got_plus_4
    jmp     *got_plus_8
    nop;    nop
    nop;    nop
.PLT1:
    jmp     *name1_in_GOT
    pushl   $offset
    jmp     .PLT0@PC
.PLT2:
    jmp     *name2_in_GOT
    pushl   $offset
    jmp     .PLT0@PC
    ...
    ...
\end{lstlisting}

\begin{itemize}
\item Quando viene creata l'immagine del processo i primi due valori
  nella GOT assumono valori particolari (spiegati di seguito)
\item Quando l'eseguibile esegue una chiamata di una funzione in una
  libreria dinamica il flusso del programma viene inidirizzato nella
  \lstinline{PLT}. Nel nostro esempio viene chiamata la funzione
  \lstinline{name1}, che avrà come indirizzo di destinazione
  l'istruzione marcata dall'etichetta \lstinline{.PLT1}
\item Il programma a questo punto esegue un \lstinline{jmp}
  all'indirizzo contenuto nell'elemento nella GOT relativo a
  \lstinline{name1}. Al momento di caricamento del programma, a
  eccezione di casi particolari come descritto di seguito, questo
  elemento è impostato con il valore dell'istruzione successiva al
  \lstinline{jmp} stesso, cioè all'istruzione alla linea 7 del listato
  \ref{cod:plt}
\item Il codice a questo punto salva sullo stack l'offset all'interno
  della tabella delle rilocazioni che permettte di individuare la
  rilocazione relativa al simbolo \lstinline{name1}. La rilocazione
  permette di ricavare sia l'elemento della \lstinline{GOT} relativo a
  quel simbolo che il nome del simbolo stesso, fornendo le
  informazioni necessarie al dynamic linker per capire quale simbolo è
  stato chiamato e qual'è l'elemento modificare nella \lstinline{GOT}.
\item A questo punto il programma salta al primo elemento della
  \lstinline{PLT} e, dopo aver salvato sullo stack il secondo elemento
  della \lstinline{GOT}, salta all'indirizzo contenuto nel terzo
  elemento della got, che dà il controllo al dynamic linker
\item Il dynamic linker esamina lo stack, controlla quale simbolo è
  stato chiamato, calcola l'indirizzo e imposta il valore
  nell'elemento relativo nella \lstinline{GOT}. In questo modo una
  seconda chiamata a \lstinline{name1} non causerà una seconda
  chiamata al linker ma salterà direttamente all'indirizzo corretto
\end{itemize}

Quest'approccio nel quale gli indirizzi delle funzioni vengono risolti
solo al momento in cui vengono chiamate si chiama \emph{lazy
  binding}. Se il programma viene eseguito con la variabile d'ambiente
\lstinline{LD_BIND_NOW} impostata gli indirizzi vengono tutti
calcolati e scritti nella \lstinline{GOT} al momento del caricamento
dell'eseguibile. Questo comportamento avviene anche quando si compila
un eseguibile con \lstinline{RELRO}. Inoltre, in questo caso, una
volta modificata la \lstinline{GOT} viene resa non più scrivibile, in
modo da mitigare attacchi di tipo got patching.




%% \subsection{Procedure Linkage Table}

%% Un entry nella PLT è cosi strutturata:

%% .PLT 
%% jmp *(0xOffsetGotTable)
%% push Index
%% jmp PLT0

%% Come possiamo vedere la funzione esegue un jmp ad un'indirizzo di
%% memoria memorizzato ad un dato offset nella \emph{Global Offset
%%   Table}. L'indirizzo che si trova a quell'indirizzo nel momento del
%% caricamento in memoria dell'eseguibile (a meno che come vedremo più
%% avanti si voglia realizzare le relocation a tempo di caricamento)è
%% l'indirizzo successivo al jmp stesso, cioè il programma mette sullo
%% stack un indice e richiamta la prima entry nella plt. Saltando nella
%% prima entry nella plt il controllo viene dato al dynamic linker che
%% utilizza l'index presente sullo stack come offset nella relocation
%% table, da quale potra ricavare informazioni come quale simbolo è stato
%% chiamato e quale offset nell GOT table vi è associato. Il linker (che
%% avengo caricato le librerie per l'eseguibile sa dove sono mappate in
%% memoria) si preoccupa di risolvere il simbolo e modificare l'offset
%% nella GOT table perchè punti a quell'indirizzo. Dopo di che ridà il
%% controllo alla funzione chiamata. In questo modo la seconda volta che
%% si chiamerà una funzione l'indirizzo della GOT table punterà già alla
%% funzione richiamata, e il linker non verrà chiamato. Si noti come
%% l'unico valore modificato si trova nella GOT table, che è mappata in
%% un apagina di memoria scrivibile ma no eseguibile, e che il codice non
%% viene mai modificato.

%% \SECTION{ASLR}

%% E' una misura di sicurezza che cerca di casualizzare il codice nella
%% memoria, in questo modo è molto difficile conoscere la posizione di
%% strutture chiave del programma, che potrebbero essere usate da un
%% attaccante per prendere controllo del programma stesso. L'ASRL è
%% abilitato di default nel kernel Linux a partire dalla versione version
%% 2.6.12 (giugno 2005), anche se già da prima esistevano vari patchset
%% per poterla abilitare. Le aree di memoria che possono essere
%% casualizzate in memoria sono diverse ed è possibile che non siano
%% tutte contemporaneamente casualizzate. Solitamente le aree di memoria
%% casualizzate sono gli indirizzi in cui vengono mappate le librerie
%% dinamiche, la porzione di memoria dove risiede lo stack e lo spazio di
%% memoria dove risiedono gli stack dei vari threads. La casualizzazione
%% del testo del programma vero è proprio non viene solitamente
%% casualizzato, o viene casualizzato solamente in caso di programmi che
%% vengono considerati più a rischio (come quelli che si espongono a
%% connessioni esterne). Questo perchè per far si che una porzione di
%% codice funzioni a prescindere da quale indirizzo risieda in memoria,
%% il codice stesso utilizzare tecniche che gli consentano di riferirsi a
%% sezioni di codice in modo relativo, aggiungendo un overhead nella
%% computazione \ref{section PIC, PIE, SharedLibrary}. Diverse tecniche
%% sono state sviluppate per eludere queste misure di sicurezza, alcune
%% delle quali cercano di utilizzare un attacco a forza bruta per
%% ottenere l'indirizzo cercato. Spesso questo è possibile grazie al
%% fatto che molti eseguibili utilizzano la funzione di libreria fork()
%% per rifar partire un processo terminato. La funzione fork riutilizza
%% lo stesso spazio degli indirizzi del processo padre, consentendo
%% quindi un attacco a forza bruta. Su implementazioni a 64bit tuttavia
%% questo tipo di attacco non è fattibile, in quanto l'entropia è molto
%% più altra rispetto alle implementazioni a 32bit. Le altre tecniche che
%% vengono utilizzate per eludere la casualizzazione degli indirizzi
%% solitamente si basano sul fatto che per quanto l'indirizzo dal quale
%% una porzione di codice viene mappata sia randomizzata, al suo interno
%% gli offset relativi tra le varie non sono modificati. Analizzando le
%% strutture dati che il programma utilizza per poter chiamare lui stesso
%% le funzioni è possibile quindi ottenere abbastanza informazioni che ci
%% permettono di dedurre attraverso semplici calcoli la posizione che ci
%% interessa.


%% \section{Write or Execute}


%% La principale complicazioni ad attacchi semplici di tipo buffer
%% overflow è che quanto si tenta di eseguire istruzioni residenti in
%% pagine marcate come scrivibili ma non eseguibili (ad esempio le aree
%% di memoria che contengono i dati manipolati dal programma e
%% specialmente lo stack) il programma termina. Questo non ha reso più
%% possibile l'iniezione diretta di uno shellcode ma ha portato ad
%% utilizzare altre tecniche che utilizzano codice già presente nel
%% programma o nelle sue librerie per portare a termine l'attacco. Le
%% aree di memoria contenenti le librerie vengono caricate ad indirizzi
%% casualizzati nelle aree di memoria. A questo punto risulta chiaro che
%% il codice del programma, essendo non modificabile, deve trovare un
%% modo per poter riferire a strutture presenti nelle librerie (come gli
%% indirizzi delle funzioni da chiamare) che invece vengono modificati ad
%% ogni esecuzione. Questo problema viene risolto, come spesso succede in
%% informatica, grazie ad un livello di astrazione. Il programma carica
%% in memoria diverse strutture dati, che vengono utilizzate dal
%% programma stesso e dal dynamic linker, nel processo di chiamata ad una
%% funziona presente di una shared library. Prima di tutto quando viene
%% effetutata una chiamata ad una funzione presente in una shared library
%% in realtà si chiama un indirizzo nella \emph{Procedure Linkage
%%   Table}. Questa tabella contiene un entry per ogni funzione che viene
%% chiamata dal programma principale, più due entry che hanno una
%% funzione principale. 
%% \section{Eludere ASRL}

%% Sono state messe appunto diverse tecniche per eludere ASRL. La più
%% semplice prende il nome di \emph{return-to-plt}. Invece di cercare di
%% tornare ad un indirizzo nello spazio di memoria della libc, si torna
%% ad all'indirizzo di memoria nel quale si richiama alla plt, nel testo
%% del programma. Ovviamente in questo modo le funzioni che possono
%% essere richiamate sono limitate a quelle utilizzate dal
%% programma. Un'altra tecnica che può essere utilizzata viene chiamata
%% \emph{GOT Patching}. La posizione della got table è presente in
%% memoria ad un indirizzo noto. Una volta che la entry nella got
%% relativa alla chiamata di una funzione viene sostituita dal dynamic
%% linker con l'indirizzo reale della funzione si può cercare una
%% sequenza di gadgets per aggiungere l'offset relativo tra quella
%% funzione e la funzione che voglio chiamare. In questo modo si può
%% ritornare nella plt, ma invece della funzione si ritornera alla
%% funzione voluta. Una tecnica per mitigare questo tipo di attacco è
%% quella di effettuare tutte le relocazioni al momento del caricamento
%% dell'eseguibile, e dopo di che rendendo la GOT table
%% read-only. Tuttavia è possibile ritrovare una sequenza di
%% gadget\cite{Sachman} che ci permetta di leggere quest'indirizzo,
%% aggiungere il nostro offset e saltare all'indirizzo calcolato.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "tesi"
%%% End: 
