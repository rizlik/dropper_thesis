\chapter{Exploit}

L'utilizzo di varie tecniche di protezione hanno reso sempre più
difficile lo sfruttamento di errori nell'esecuzione di un programma al
fine di prenderne il controllo. Questo capitolo introduce brevemente
alcune di queste tecniche e analizza con quali metodi è possibile
eluderle. Anche se alcuni concetti sono indipendenti dall'architettura
e dal sistema operativo questo capitolo tratterà esclusivamente di come
queste tecniche sono implementate in ambiente GNU/Linux, su
architettura 8086 e amd64. Nella prima parte di questo capitolo si
parlerà brevemente dei principali meccanismi con i quali il sistema
operativo, partendo dalle informazioni presenti all'interno di un file
oggetto eseguibile, crea una rappresentazione dinamica del programma,
detta \emph{immagine del processo}. Una volta creata l'immagine del
processo il controllo viene ceduto al programma che inizia la sua
esecuzione. La prossima sezione si soffermerà solo sulle parti
rilevanti per il lavoro svolto.

\section{ELF, loading}

ELF (Executable and Linkable Format) viene utilizzato per 
rappresentare tre tipi di file oggetto:

\begin{itemize}
  \item \emph{file oggetto rilocabile}: contiene dati e codice che
    vengono collegati ad altri file oggetto al fine di ottenere un
    \emph{file oggetto eseguibile} o un \emph{file oggetto condiviso}

  \item \emph{file oggetto eseguibile}: è la rappresentazione statica
    di un programma che può essere eseguito, questo file ha le
    informazioni necessarie affinché il sistema operativo crei la sua
    immagine di processo

  \item \emph{file oggetto condiviso} che contiene codice e dati
    adatti per essere collegati (nel processo di linking) in due
    contesti differenti. Può essere infatti utilizzato sia in fase di
    building insieme ad altri file oggetto rilocabile o file oggetto
    condivisi (\emph{linking statico}) per creare altri file oggetto,
    oppure può essere collegato in fase di creazione dell'immagine del
    processo di un file oggetto eseguibile (\emph{linking dinamico}).

\end{itemize}

Il formato ELF può contenere sia le informazioni necessarie per
processi relativi alla fase di creazione di diversi file oggetto a
partire da file sorgente (in particolare informazioni necessarie per
la fase di linking), sia relativamente allo scopo della creazione
dell'immagine di un processo a partire da un file oggetto
eseguibile. Anche le strutture dati all'interno dell'ELF responsabili
di questi due ``punti di vista'' sono differenti, e, a seconda della
tipologia del file oggetto alcune delle strutture dati possono non
essere presenti. Essendo più rilevante ai fini del nostro lavoro ci
concentreremo principalmente sulle strutture dati rilevanti nelle
operazioni di creazione dell'immagine del processo e nelle procedure
di dynamic linking, ovvero nel processo con il quale si rendono
fruibili all'eseguibile i metodi esposti da una libreria condivisa a
tempo di esecuzione.

\subsection{Program header table}

L'ELF header (che è l'unica struttura dati che ha una posizione fissa
all'interno del file) funge da una sorta di mappa, e ci consente di
localizzare tutte le altre strutture dati presenti nel file.

Tra queste vi è la \emph{Program header table}. La program header
table è un array di strutture, ognuna delle quali contiene o
informazioni su come costruire un segmento della memoria dell'immagine
di un processo o informazioni per la preparazione dell'immagine
stessa. Una entry all'interno della program header table (su
un'architettura a 32bit) è rappresentata dalla seguente struttura C:

\begin{lstlisting}[caption=program header table entry]
typedef struct {
  uint32_t   p_type;
  Elf32_Off  p_offset;
  Elf32_Addr p_vaddr;
  Elf32_Addr p_paddr;
  uint32_t   p_filesz;
  uint32_t   p_memsz;
  uint32_t   p_flags;
  uint32_t   p_align;
} Elf32_Phdr;
\end{lstlisting}

La struttura relativa ad un'architettura a 64bit è pressoché identica,
l'unica differenza sta nella posizione degli attributi.  L'attributo
\lstinline{ptype} indica il tipo di entry. Per il nostro scopo ci
limiteremo a descrivere le entry di tipo \lstinline{PT_LOAD},
\lstinline{PT_INTERPETER} e \lstinline{PT_DYNAMIC}. Le entry di tipo
\lstinline{PT_LOAD} rappresentano informazioni su un segmento da
caricare in memoria. Il campo \lstinline{p_offset} e
\lstinline{p_filesz} indicano rispettivamente l'offset e la sua
grandezza all'interno del file. \lstinline{p_vaddr} e
\lstinline{p_memsz} invece indicano rispettivamente il base address
nel quale caricare in memoria il segmento e la dimensione che avrà in
memoria (che potrebbe essere più grande rispetto a quella sul
file). \lstinline{p_flags} è molto rilevante per il nostro lavoro e
indica con quali flags il segmento andrà ad essere caricato in memoria
ovvero se il segmento sarà o meno scrivibile, leggibile e/o
eseguibile. Tuttavia nel caso il segmento contenga codice compilato
affinché risulti indipendente dal indirizzo base nel quale risiede in
memoria, il campo \lstinline{p_vaddr} potrebbe essere nullo e la
posizione del segmento in memoria potrebbe essere casualizzata.

La voce all'interno della program header table con il tipo
\lstinline{PT_INTERP} invece contiene una stringa che rappresenta il
percorso di un file oggetto eseguibile o condiviso all'interno del
filesystem, detto interprete. Il sistema operativo crea l'immagine del
processo dell'interprete, dandogli il controllo. Sarà compito poi
dell'interprete creare l'immagine del processo necessaria
all'esecuzione dell'eseguibile. Affinché questo possa accadere
l'interprete avrà accesso alle informazioni presenti nel file
principale. Normalmente l'interprete è costituito da codice
indipendente dalla posizione nella quale viene caricato, che viene
casualizzata evitando conflitti tra gli spazi di memoria utilizzati
dall'eseguibile principale e quelli dell'interprete stesso.

Quando viene creato del codice oggetto che utilizza delle librerie
dinamiche, il linker aggiunge alla program header table un elemento di
tipo \lstinline{PT_INTERPRETER} con impostato come interprete il
\emph{dynamic linker}, che si occupa di trovare le librerie necessarie
all'eseguibile, caricarle in memoria, caricare in memoria i segmenti
dell'eseguibile, risolvere le relocation verso i simboli delle
librerie, e ridare poi controllo all'eseguibile stesso. Come vedremo
la risoluzione di un simbolo potrebbe essere rimandata fin quando non
sia realmente necessario. A supporto di questi processi troviamo
alcune strutture dati, anch'esse aggiunte al file oggetto eseguibile
durante la fase di linking. Queste strutture risiedono all'interno di
segmenti che vengono caricati in memoria, e sono quindi disponibili
durante l'esecuzione del programma. Informazioni su dove trovare
queste strutture dati possono essere ricavati attraverso un'altra
struttura dati del file ELF, la \emph{Section header table}, che è un
array di strutture che descrivono, per l'appunto, le parti che
compongono il file. Tuttavia, anche se anche nel nostro lavoro di tesi
le section vengono utilizzate per ottenere informazioni sul binario
esaminato, è da notare che esse non sono necessarie per un file
oggetto di tipo eseguibile. Un file oggetto infatti può essere
caricato esclusivamente con le informazioni presenti nella program
header table (lo strumento sstrip\cite{sstrip} elimina appunto le
sezioni da un file eseguibile). Tuttavia è conveniente per scopi
illustrativi riferirsi alle strutture dati relative al processo di
dynamic linking esaminandone le rispettive sezioni:

\begin{itemize}

  \item Una sezione \lstinline{.dynamic} che contiene gli indirizzi di
    altre strutture necessarie al processo di dynamic linking e la
    lista delle librerie necessarie all'esecuzione del file oggetto
    eseguibile

  \item Una sezione \lstinline{.hash} che contiene una tabella dei
    simboli

  \item Le sezioni \lstinline{.got} e \lstinline{.plt} contengono
    rispettivamente due tabelle: \emph{la global offset table} e
    \emph{la procedure linkage table}. Nelle sezioni successive
    vedremo come queste due strutture dati vengono utilizzate dal
    dynamic linker per risolvere i simboli e le chiamate a funzioni
    presenti nelle librerie dinamiche

\end{itemize}

\subsection{Global Offset Table e Procedure Linkage Table}

Un programma che sia indipendente dalla posizione in cui viene
caricato in memoria non può contenere al suo interno indirizzi
assoluti. Le global offset table (\lstinline{GOT}) contengono
indirizzi assoluti in un'area di memoria privata destinata ai dati,
non compromettendo quindi il fatto che il codice sia indipendente
dalla posizione (e quindi che sia condivisibile da più immagini di
processo, come nel caso di una libreria dinamica). Il linker, una
volta creata l'immagine di un processo, processa tutte le rilocazioni
(strutture dati che contengono informazioni per la risoluzione dei
simboli) di tipo \lstinline{R_386_GLOB_DAT} e per ognuna di esse
calcola l'indirizzo assoluto. Il linker conoscendo l'indirizzo di
tutti i file oggetto caricati in memoria ha tutte le informazioni
necessarie per calcolare il valore di questi indirizzi. Una volta
calcolati il linker inserisce i valori assoluti nei rispettivi
elementi della \lstinline{GOT}, permettendo all'eseguibile di
accedervi attraverso posizioni relative.

A noi interessa principalmente come la \lstinline{GOT} è coinvolti nel
momento in cui un file oggetto eseguibile esegue una chiamata ad una
funzione di una libreria dinamica, processo in cui è coinvolta anche
una seconda tabella, la procedure linkage table (\lstinline{PLT}).

La procedure linkage table redireziona chiamate a funzioni che non
siano dipendenti dalla posizione a valori assoluti non conosciuti al
momento della fase di linking di un eseguibile. Infatti in fase di
building di un eseguibile il linker fa in modo che le chiamate a
queste funzioni vengano direzionate a elementi della
\lstinline{PLT}. Anche se la \lstinline{PLT} risiede nel segmento di
memoria destinato a contenere il codice di un eseguibile, utilizza
valori nella global offset table, non compromettendo così né
l'indipendenza dalla posizione ne la condivisibilità del codice. È
compito del dynamic linker calcolare i valori degli indirizzi della
funzione ei impostarli nei relativi elementi della
\lstinline{GOT}. Nella restante parte di questa sezione andremo a
descrivere come il dynamic linker utilizza queste due tabelle per
risolvere gli indirizzi. È da notare che faremo riferimento
all'implementazione su un'architettura a 32bit. Tuttavia il concetto
principale resta pressoché invariato anche per un'architettura a
64bit. La \lstinline{PLT} è strutturata come nel listato
\ref{cod:plt}.

\begin{lstlisting}[caption=Procedure linkage table, label=cod:plt]
.PLT0:
    pushl   got_plus_4
    jmp     *got_plus_8
    nop;    nop
    nop;    nop
.PLT1:
    jmp     *name1_in_GOT
    pushl   $offset
    jmp     .PLT0@PC
.PLT2:
    jmp     *name2_in_GOT
    pushl   $offset
    jmp     .PLT0@PC
    ...
    ...
\end{lstlisting}

\begin{itemize}
\item Quando viene creata l'immagine del processo i primi due valori
  nella GOT assumono valori particolari (spiegati di seguito)
\item Quando l'eseguibile esegue una chiamata di una funzione in una
  libreria dinamica il flusso del programma viene inidirizzato nella
  \lstinline{PLT}. Nel nostro esempio viene chiamata la funzione
  \lstinline{name1}, che avrà come indirizzo di destinazione
  l'istruzione marcata dall'etichetta \lstinline{.PLT1}
\item Il programma a questo punto esegue un \lstinline{jmp}
  all'indirizzo contenuto nell'elemento nella GOT relativo a
  \lstinline{name1}. Al momento di caricamento del programma, a
  eccezione di casi particolari come descritto di seguito, questo
  elemento è impostato con il valore dell'istruzione successiva al
  \lstinline{jmp} stesso, cioè all'istruzione alla linea 7 del listato
  \ref{cod:plt}
\item Il codice a questo punto salva sullo stack l'offset all'interno
  della tabella delle rilocazioni che permettte di individuare la
  rilocazione relativa al simbolo \lstinline{name1}. La rilocazione
  permette di ricavare sia l'elemento della \lstinline{GOT} relativo a
  quel simbolo che il nome del simbolo stesso, fornendo le
  informazioni necessarie al dynamic linker per capire quale simbolo è
  stato chiamato e qual'è l'elemento modificare nella \lstinline{GOT}.
\item A questo punto il programma salta al primo elemento della
  \lstinline{PLT} e, dopo aver salvato sullo stack il secondo elemento
  della \lstinline{GOT}, salta all'indirizzo contenuto nel terzo
  elemento della got, che dà il controllo al dynamic linker
\item Il dynamic linker esamina lo stack, controlla quale simbolo è
  stato chiamato, calcola l'indirizzo e imposta il valore
  nell'elemento relativo nella \lstinline{GOT}. In questo modo una
  seconda chiamata a \lstinline{name1} non causerà una seconda
  chiamata al linker ma salterà direttamente all'indirizzo corretto
\end{itemize}

Quest'approccio nel quale gli indirizzi delle funzioni vengono risolti
solo al momento in cui vengono chiamate si chiama \emph{lazy
  binding}. Se il programma viene eseguito con la variabile d'ambiente
\lstinline{LD_BIND_NOW} impostata gli indirizzi vengono tutti
calcolati e scritti nella \lstinline{GOT} al momento del caricamento
dell'eseguibile. Questo comportamento avviene anche quando si compila
un eseguibile con \lstinline{RELRO}. Inoltre, in questo caso, una
volta modificata la \lstinline{GOT} viene resa non più scrivibile, in
modo da mitigare attacchi di tipo got patching.


\section{Return oriented programming}

Per mitigare classici attacchi di tipo stack-smashing sono state
elaborate diverse tecniche per precludere la possibilità di eseguire
il codice iniettato da un attaccante. La prima di questa tecniche è
stata implementata in una patch di Solar Designer \cite{stackpatch},
che modifica lo schema della memoria dell'immagine di un processo al
fine di rendere le istruzioni presenti nello stack non eseguibili. Dato
che nella maggior parte dei casi l'attaccante utilizzava lo stack come
locazione del codice iniettato questa patch rendeva innocui molti di
questi attacchi. Una tecnica più completa, chiamata ``$W \oplus X$'',
assicura invece che non ci sia una pagina di memoria all'interno del
processo che sia scrivibile ed eseguibile nello stesso momento. Per
eludere questa tecnica un attaccante è costretto a non utilizzare più
codice da lui stesso iniettato ma codice già presente nell'immagine
del processo bersaglio (il primo a suggerire quest'approccio è stato
Solar Designer \cite{solar-return-to-libc}). Dato che la libreria C
standard è praticamente utilizzata in quasi tutti i programmi Unix e
contiene funzioni utili ad un attaccante (come \lstinline{system} o
\lstinline{execve}) il codice utilizzato solitamente è proprio quello
della libc, da cui il nome con cui vengono catalogati questo tipo di
attacchi: \emph{return-to-libc}. Tra le misure per mitigare attacchi
di questo tipo fu ipotizzato la rimozione di alcune funzioni dalle
libc al fine di rendere questo tipo di attacchi meno efficace. Shacham
in \cite{Shacham-2007} ha evidenziato come questo tipo di protezione
fosse in realtà inefficace introducendo per la prima volta la tecnica
da lui battezzata come \emph{Return Oriented Programming} (ROP), in
cui venivano usate piccole serie di istruzioni di codice già presente
nell'immagine del processo e non intere funzioni come in attacchi di
tipo return-to-libc. Anche se, in questa prima applicazione, la
tecnica estrapolava queste serie di istruzioni dalla libc, in
\cite{payla} è stato evidenziato come questa tecnica restasse valida
nonostante le istruzioni venissero direttamente prelevate dal testo
dell'eseguibile e non dalle sue librerie. In questo modo si può
utilizzare la \lstinline{ROP} per eludere tutta un'altra serie di
protezioni che si basano sulla casualizzazione della posizione di aree
di memoria chiave all'interno dell'immagine del processo di un
eseguibile (in particolar modo delle aree che contengono le librerie
condivise e di quella riservata allo stack) detta appunto \emph{Addres
  Space Layout Randomization}(ASLR). Nell'applicazione della
\lstinline{ROP} vengono individuate piccole serie di istruzioni con
delle particolari caratteristiche, chiamate \emph{gadget}. Arrangiando
minuziosamente lo stack si possono eseguire gadget uno dietro l'altro,
cicli o computazioni arbitrarie. Un punto importante è che, almeno per
quanto riguarda l'architettura intel, possono essere individuate
all'interno di un file oggetto molte sequenze di istruzioni che non
sono ``intenzionali'', ovvero inserite dal compilatore come le
istruzioni relative alla traduzione di codice sorgente. Infatti,
essendo la codifica delle istruzioni in linguaggio macchina molto
densa e non allineata, se si iniziano ad interpretare le istruzioni
partendo dal centro di un'altra istruzione, vi è molta probabilità di
decodificare una sequenza di istruzioni alternativa e valida. Questo è
dovuto alla natura stessa della codifica, quello che Shacham chiama
geometria.

\subsection{Gadget}

In questa sezione analizzeremo più in dettaglio i gadget e le loro
caratteristiche. Bisogna innanzitutto considerare che essendo i gadget
composti da una piccola serie di istruzioni questo tipo di attacchi
agisce ad un livello più basso rispetto a quello degli attacchi di
tipo return to libc. I gadget possono essere visti come delle
istruzioni di basso livello di uno strano calcolatore. Queste
istruzioni non vengono concatenate in maniera standard ma arrangiando
minuziosamente i valori presenti nello stack. I gadget sono terminati
dall'istruzione \lstinline{ret} e nelle istruzioni che lo compongono
non sono contenuti salti e altre istruzioni che deviano in qualche
modo il flusso del programma (tecniche che utilizzano anche questo
tipo di gadget sono state sviluppate, come in
\cite{JOP}). Aggiuntando lo stack in modo che nel momento in cui il
flusso del programma arrivi all'istruzione \lstinline{ret} di un
gadget il registro dello stack punti alla zona di memoria che contiene
l'indirizzo del prossimo gadget si riesce a concatenare un gadget al
successivo. I gadget, soli o in combinazione, possono svolgere diverse
funzioni. Per quanto riguarda, ad esempio, le operazioni di lettura o
scrittura possiamo notare che:

\begin{itemize}
\item gadget del tipo \lstinline{pop REG;ret} ci permettono di
caricare una costante in un registro

\item gadget del tipo \lstinline{mov reg1 ,[reg2 + imm];ret} ci
  permettono di leggere un valore dalla memoria (il valore di
  \lstinilne{reg2} può essere impostato con un gadget del punto
  precedente) e scriverlo su un registro

\item gadget del tipo \lstinline{mov [reg1 + imm], reg2} ci permettono
  di scrivere in una posizione di memoria (i valori di
  \lstinline{reg1} e \lstinline{reg2} possono essere impostati con
  gadget che ci consentono di caricare una costante di un registro)
\end{itemize}

In base all'eseguibile che stiamo considerando però potrebbero non
essere disponibili gadget esattamente come questi.  In particolare
potrebbero presentarsi altre istruzioni tra quella che a noi
effettivamente interessa (perché svolge la funzione a noi ``utile'') e
l'istruzione \lstinline{ret}. A volte modificando opportunamente lo
stack si può fare in modo che gli effetti di queste istruzioni non
incidano sulla nostra computazione. Ovviamente altri gadget, o
sequenze di gadget, possono svolgere funzioni equivalenti e, il fatto
che una categoria di gadget non è disponibile non implica che la
stessa funzione non possa essere svolta utilizzando gadget e/o
strategie differenti. Ad esempio se non abbiamo a disposizione un
gadget che ci permetta di impostare il registro \lstinline{eax}
tramite \lstinline{pop eax;ret} un'opportuna combinazione di
\lstinline{mov eax, 0xFFFFFFFF;ret} e \lstinline{inc eax;ret} ci
permette (non considerando restrizioni sulla lunghezza del payload) di
impostare valori arbitrari in \lstinline{eax}. Estrapolare, in maniera
automatica, sequenze e combinazioni di gadget che ci permettano di
raggiungere condizioni desiderate o gestire gli effetti secondari
delle istruzioni ``superflue'' è uno dei maggiori problemi di questo
lavoro di tesi.


%% \subsection{Procedure Linkage Table}


%% \SECTION{ASLR}

%% E' una misura di sicurezza che cerca di casualizzare il codice nella
%% memoria, in questo modo è molto difficile conoscere la posizione di
%% strutture chiave del programma, che potrebbero essere usate da un
%% attaccante per prendere controllo del programma stesso. L'ASRL è
%% abilitato di default nel kernel Linux a partire dalla versione version
%% 2.6.12 (giugno 2005), anche se già da prima esistevano vari patchset
%% per poterla abilitare. Le aree di memoria che possono essere
%% casualizzate in memoria sono diverse ed è possibile che non siano
%% tutte contemporaneamente casualizzate. Solitamente le aree di memoria
%% casualizzate sono gli indirizzi in cui vengono mappate le librerie
%% dinamiche, la porzione di memoria dove risiede lo stack e lo spazio di
%% memoria dove risiedono gli stack dei vari threads. La casualizzazione
%% del testo del programma vero è proprio non viene solitamente
%% casualizzato, o viene casualizzato solamente in caso di programmi che
%% vengono considerati più a rischio (come quelli che si espongono a
%% connessioni esterne). Questo perchè per far si che una porzione di
%% codice funzioni a prescindere da quale indirizzo risieda in memoria,
%% il codice stesso utilizzare tecniche che gli consentano di riferirsi a
%% sezioni di codice in modo relativo, aggiungendo un overhead nella
%% computazione \ref{section PIC, PIE, SharedLibrary}. Diverse tecniche
%% sono state sviluppate per eludere queste misure di sicurezza, alcune
%% delle quali cercano di utilizzare un attacco a forza bruta per
%% ottenere l'indirizzo cercato. Spesso questo è possibile grazie al
%% fatto che molti eseguibili utilizzano la funzione di libreria fork()
%% per rifar partire un processo terminato. La funzione fork riutilizza
%% lo stesso spazio degli indirizzi del processo padre, consentendo
%% quindi un attacco a forza bruta. Su implementazioni a 64bit tuttavia
%% questo tipo di attacco non è fattibile, in quanto l'entropia è molto
%% più altra rispetto alle implementazioni a 32bit. Le altre tecniche che
%% vengono utilizzate per eludere la casualizzazione degli indirizzi
%% solitamente si basano sul fatto che per quanto l'indirizzo dal quale
%% una porzione di codice viene mappata sia randomizzata, al suo interno
%% gli offset relativi tra le varie non sono modificati. Analizzando le
%% strutture dati che il programma utilizza per poter chiamare lui stesso
%% le funzioni è possibile quindi ottenere abbastanza informazioni che ci
%% permettono di dedurre attraverso semplici calcoli la posizione che ci
%% interessa.


%% \section{Write or Execute}


%% La principale complicazioni ad attacchi semplici di tipo buffer
%% overflow è che quanto si tenta di eseguire istruzioni residenti in
%% pagine marcate come scrivibili ma non eseguibili (ad esempio le aree
%% di memoria che contengono i dati manipolati dal programma e
%% specialmente lo stack) il programma termina. Questo non ha reso più
%% possibile l'iniezione diretta di uno shellcode ma ha portato ad
%% utilizzare altre tecniche che utilizzano codice già presente nel
%% programma o nelle sue librerie per portare a termine l'attacco. Le
%% aree di memoria contenenti le librerie vengono caricate ad indirizzi
%% casualizzati nelle aree di memoria. A questo punto risulta chiaro che
%% il codice del programma, essendo non modificabile, deve trovare un
%% modo per poter riferire a strutture presenti nelle librerie (come gli
%% indirizzi delle funzioni da chiamare) che invece vengono modificati ad
%% ogni esecuzione. Questo problema viene risolto, come spesso succede in
%% informatica, grazie ad un livello di astrazione. Il programma carica
%% in memoria diverse strutture dati, che vengono utilizzate dal
%% programma stesso e dal dynamic linker, nel processo di chiamata ad una
%% funziona presente di una shared library. Prima di tutto quando viene
%% effetutata una chiamata ad una funzione presente in una shared library
%% in realtà si chiama un indirizzo nella \emph{Procedure Linkage
%%   Table}. Questa tabella contiene un entry per ogni funzione che viene
%% chiamata dal programma principale, più due entry che hanno una
%% funzione principale. 
%% \section{Eludere ASRL}

%% Sono state messe appunto diverse tecniche per eludere ASRL. La più
%% semplice prende il nome di \emph{return-to-plt}. Invece di cercare di
%% tornare ad un indirizzo nello spazio di memoria della libc, si torna
%% ad all'indirizzo di memoria nel quale si richiama alla plt, nel testo
%% del programma. Ovviamente in questo modo le funzioni che possono
%% essere richiamate sono limitate a quelle utilizzate dal
%% programma. Un'altra tecnica che può essere utilizzata viene chiamata
%% \emph{GOT Patching}. La posizione della got table è presente in
%% memoria ad un indirizzo noto. Una volta che la entry nella got
%% relativa alla chiamata di una funzione viene sostituita dal dynamic
%% linker con l'indirizzo reale della funzione si può cercare una
%% sequenza di gadgets per aggiungere l'offset relativo tra quella
%% funzione e la funzione che voglio chiamare. In questo modo si può
%% ritornare nella plt, ma invece della funzione si ritornera alla
%% funzione voluta. Una tecnica per mitigare questo tipo di attacco è
%% quella di effettuare tutte le relocazioni al momento del caricamento
%% dell'eseguibile, e dopo di che rendendo la GOT table
%% read-only. Tuttavia è possibile ritrovare una sequenza di
%% gadget\cite{Sachman} che ci permetta di leggere quest'indirizzo,
%% aggiungere il nostro offset e saltare all'indirizzo calcolato.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "tesi"
%%% End: 
