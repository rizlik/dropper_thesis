\chapter{Exploit}

L'utilizzo di varie tecniche di protezione hanno reso sempre più
difficile lo sfruttamento di errori nell'esecuzione di un programma al
fine di prenderne il controllo. Questo capitolo introduce brevemente
alcune di queste tecniche e analizza con quali metodi è possibile
eluderle. Anche se alcuni concetti sono indipendenti dall'architettura
e dal sistema operativo questo capitolo tratterà eslusivamente di come
queste tecniche sono implementate in ambiente GNU/Linux, su
archiettura 8086 e amd64. Nella prima parte di questo capitolo si
parlerà brevemente dei principali meccanismi con i quali il sistema
operativo, partendo dalle informazioni presenti all'interno di un file
oggetto eseguibile, crea una rappresentazione dinamica del programma,
detta \emph{immagine del processo}. Una volta creata l'immagine del
processo il controllo viene ceduto al programma che inizia la sua
esecuzione. La prossima sezione si soffermerà solo sulle parti
rilevanti per il lavoro svolto, per ulteriori approfondimenti
consultare \cited{}.

\section{ELF, loading}

ELF (Executable and Linkable Format) viene utilizzato per 
rappresentare tre tipi di file oggetto:

\begin{itemize}
  \item \emph{file oggetto rilocabile}: contiene dati e codice che
    vengono collegati ad altri file oggetto al fine di ottenere un
    \emph{file oggetto eseguibile} o \emph{file oggetto condiviso}

  \item \emph{file oggetto eseguibile}: contiene un programma adatto per la
    sua esecuzione, questo file ha le informazioni necessarie affinchè
    il sistema operativo crei la sua immagine di processo

  \item \emph{file oggetto condiviso} che contiene codice e dati
    adatti per essere collegati (nel processo di linking) in due
    contesti differenti. Può essere infatti utilizzato sia in fase di
    linking statico insieme ad altri file oggetto rilocabili o file
    oggetto condivisi per creare altri file oggetto, oppure può essere
    collegato in fase di creazione dell'immagine del processo di un
    file oggetto eseguibile.
\end{itemize}

Il formato ELF può contenere sia le informazioni necessarie per
processi relativi alla fase di creazione di diversi file oggetto a
partire da file sorgente (in particolare informazioni necessarie per
la fase di linking), sia relativamente allo scopo della creazione
dell'immagine di un processo a partire da un file oggetto
eseguibile. Anche le strutture dati all'interno dell'ELF responsabili
di questi due ``punti di vista'' sono diffrerenti, e, a seconda della
tipologia del file oggetto alcune delle strutture dati possono non
essere presenti. Essendo più rilevante ai fini del nostro lavoro ci
concentreremo solo sulle principali strutture dati all'interno
dell'ELF rilevanti al fine di creare l'immagine di un processo.

\subsection{Program header table}

L'ELF header (che è l'unica struttra dati che ha una posizione fissa
all'interno del file) funge da una sorta di mappa, e ci consente di
localizzare tutte le altre stuture dati presenti nel file.

Tra queste vi è la \emph{Program header table}. La program header table è
un array di strutture, ognuna delle quali contiene o informazioni su
come costruire un segmento della memoria dell'immagine di un processo
o informazioni per la preparazione dell'immagine stessa. Una entry
all'interno della program header table è rappresentata dalla seguente
struttura C:



L'attributo ptype indica il tipo di entry. Per il nostro scopo ci
limiteremo a descrivere le entry di tipo PTLOAD, PTINTERPETER e
PTDYNAMIC. Le entry di tipo ptload rappresentano informazioni su un
segmento da caricare in memoria. Il campo offset e filesz indicano
rispettivamente l'offset e la sua grandezza all'interno del
file. pvaddr e pmemsz invece indicano rispettivamente il base
address nel quale caricare in memoria il segmento e la dimensione che
avrà in memoria (che potrebbe essere più grande rispetto a
filesz). pflags è molto rilevante per il nostro lavoro e indica con
quali flags il segmento andrà ad essere caricato in memoria ovvero se
il segmento sarà o meno scrivibile, leggibile e/o eseguibile. Tuttavia
nel caso il segmento contenga codice compilato affichè risulti
indipendente dal indirizzo base nel quale risiede in memoria, il campo
pvaddr potrebbe essere nullo e la posizione del segmento in memoria
potrebbe essere casualizzata (vedi \ref{}).

La voce all'interno della program header table con il tipo PTINTERP
invece contiene una stringa che rappresenta il percorso di un file
oggetto eseguibile o condiviso all'interno del filesystem, detto
interprete. Il sistema operativo crea l'immagine del processo
l'interprete, dandogli il controllo e la possibilità di accedere alle
informazioni presenti nel file oggetto principale. Sarà compito poi
dell'interprete creare l'ambiente necessario all'esecuzione dell'
eseguibile. Normalmente l'interprete è costituito da codice
indipendente dalla posizione nella quale viene caricato, che viene
casualizzata evitando conflitti tra gli spazi di memoria utilizzati
dall'eseguibile principale e quelli dell'interprete stesso.

Quando viene creato del codice oggetto che utilizza delle librerie
dinamice, il linker aggiunge alla program header teble un elemento di
tipo tinterpreter indicando come interprete il \emph{dynamic
  linker}, che si occupa di trovare le librerie necessarie
all'eseguibile, caricarle in memoria, caricare in memoria i segmenti
dell'eseguibile, risolvere le relocation verso i simboli delle
librerie, e ridare poi controllo all'eseguibile stesso. Come vedremo
la risoluzione di un simbolo potrebbe essere rimandata fin quando non
sia realmente necessario. Questo modo di risolvere i simboli viene
denominato \emph{lazy binding}. A supporto di questi processi troviamo
alcune strutture dati, anch'esse aggiunte al file oggetto eseguibile
durante la fase di linking. Queste strutture risiedono all'interno di
segmenti che vengono caricati in memoria, e sono quindi disponibili
durante l'esecuzione del programma.

\begin{itemize}

  \item Una .dynamic section che contiene gli inidirizzi di altre
    strutture necessarie al processo di dynamic linking e la lisa delqle librerie
    necessarie all'esecuzione del file oggetto eseguibile

  \item Una .hash section contiene una tabella dei simboli

  \item La .got e .plt contengono rispettivamente due tabelle:
    \emph{la global offset table} e \emph{la procedure linkage
      table}. Nelle sezioni successive vedremo come queste due
    strutture dati vengono utilizzate dal dynamic linker per risolvere
    i simboli e le chiamate a funzioni presenti nelle librerie
    dinamiche utilizzate dal'eseguibile
\end{itemize}

%% \subsection{Procedure Linkage Table}

%% Un entry nella PLT è cosi strutturata:

%% .PLT 
%% jmp *(0xOffsetGotTable)
%% push Index
%% jmp PLT0

%% Come possiamo vedere la funzione esegue un jmp ad un'indirizzo di
%% memoria memorizzato ad un dato offset nella \emph{Global Offset
%%   Table}. L'indirizzo che si trova a quell'indirizzo nel momento del
%% caricamento in memoria dell'eseguibile (a meno che come vedremo più
%% avanti si voglia realizzare le relocation a tempo di caricamento)è
%% l'indirizzo successivo al jmp stesso, cioè il programma mette sullo
%% stack un indice e richiamta la prima entry nella plt. Saltando nella
%% prima entry nella plt il controllo viene dato al dynamic linker che
%% utilizza l'index presente sullo stack come offset nella relocation
%% table, da quale potra ricavare informazioni come quale simbolo è stato
%% chiamato e quale offset nell GOT table vi è associato. Il linker (che
%% avengo caricato le librerie per l'eseguibile sa dove sono mappate in
%% memoria) si preoccupa di risolvere il simbolo e modificare l'offset
%% nella GOT table perchè punti a quell'indirizzo. Dopo di che ridà il
%% controllo alla funzione chiamata. In questo modo la seconda volta che
%% si chiamerà una funzione l'indirizzo della GOT table punterà già alla
%% funzione richiamata, e il linker non verrà chiamato. Si noti come
%% l'unico valore modificato si trova nella GOT table, che è mappata in
%% un apagina di memoria scrivibile ma no eseguibile, e che il codice non
%% viene mai modificato.

%% \SECTION{ASLR}

%% E' una misura di sicurezza che cerca di casualizzare il codice nella
%% memoria, in questo modo è molto difficile conoscere la posizione di
%% strutture chiave del programma, che potrebbero essere usate da un
%% attaccante per prendere controllo del programma stesso. L'ASRL è
%% abilitato di default nel kernel Linux a partire dalla versione version
%% 2.6.12 (giugno 2005), anche se già da prima esistevano vari patchset
%% per poterla abilitare. Le aree di memoria che possono essere
%% casualizzate in memoria sono diverse ed è possibile che non siano
%% tutte contemporaneamente casualizzate. Solitamente le aree di memoria
%% casualizzate sono gli indirizzi in cui vengono mappate le librerie
%% dinamiche, la porzione di memoria dove risiede lo stack e lo spazio di
%% memoria dove risiedono gli stack dei vari threads. La casualizzazione
%% del testo del programma vero è proprio non viene solitamente
%% casualizzato, o viene casualizzato solamente in caso di programmi che
%% vengono considerati più a rischio (come quelli che si espongono a
%% connessioni esterne). Questo perchè per far si che una porzione di
%% codice funzioni a prescindere da quale indirizzo risieda in memoria,
%% il codice stesso utilizzare tecniche che gli consentano di riferirsi a
%% sezioni di codice in modo relativo, aggiungendo un overhead nella
%% computazione \ref{section PIC, PIE, SharedLibrary}. Diverse tecniche
%% sono state sviluppate per eludere queste misure di sicurezza, alcune
%% delle quali cercano di utilizzare un attacco a forza bruta per
%% ottenere l'indirizzo cercato. Spesso questo è possibile grazie al
%% fatto che molti eseguibili utilizzano la funzione di libreria fork()
%% per rifar partire un processo terminato. La funzione fork riutilizza
%% lo stesso spazio degli indirizzi del processo padre, consentendo
%% quindi un attacco a forza bruta. Su implementazioni a 64bit tuttavia
%% questo tipo di attacco non è fattibile, in quanto l'entropia è molto
%% più altra rispetto alle implementazioni a 32bit. Le altre tecniche che
%% vengono utilizzate per eludere la casualizzazione degli indirizzi
%% solitamente si basano sul fatto che per quanto l'indirizzo dal quale
%% una porzione di codice viene mappata sia randomizzata, al suo interno
%% gli offset relativi tra le varie non sono modificati. Analizzando le
%% strutture dati che il programma utilizza per poter chiamare lui stesso
%% le funzioni è possibile quindi ottenere abbastanza informazioni che ci
%% permettono di dedurre attraverso semplici calcoli la posizione che ci
%% interessa.


%% \section{Write or Execute}


%% La principale complicazioni ad attacchi semplici di tipo buffer
%% overflow è che quanto si tenta di eseguire istruzioni residenti in
%% pagine marcate come scrivibili ma non eseguibili (ad esempio le aree
%% di memoria che contengono i dati manipolati dal programma e
%% specialmente lo stack) il programma termina. Questo non ha reso più
%% possibile l'iniezione diretta di uno shellcode ma ha portato ad
%% utilizzare altre tecniche che utilizzano codice già presente nel
%% programma o nelle sue librerie per portare a termine l'attacco. Le
%% aree di memoria contenenti le librerie vengono caricate ad indirizzi
%% casualizzati nelle aree di memoria. A questo punto risulta chiaro che
%% il codice del programma, essendo non modificabile, deve trovare un
%% modo per poter riferire a strutture presenti nelle librerie (come gli
%% indirizzi delle funzioni da chiamare) che invece vengono modificati ad
%% ogni esecuzione. Questo problema viene risolto, come spesso succede in
%% informatica, grazie ad un livello di astrazione. Il programma carica
%% in memoria diverse strutture dati, che vengono utilizzate dal
%% programma stesso e dal dynamic linker, nel processo di chiamata ad una
%% funziona presente di una shared library. Prima di tutto quando viene
%% effetutata una chiamata ad una funzione presente in una shared library
%% in realtà si chiama un indirizzo nella \emph{Procedure Linkage
%%   Table}. Questa tabella contiene un entry per ogni funzione che viene
%% chiamata dal programma principale, più due entry che hanno una
%% funzione principale. 
%% \section{Eludere ASRL}

%% Sono state messe appunto diverse tecniche per eludere ASRL. La più
%% semplice prende il nome di \emph{return-to-plt}. Invece di cercare di
%% tornare ad un indirizzo nello spazio di memoria della libc, si torna
%% ad all'indirizzo di memoria nel quale si richiama alla plt, nel testo
%% del programma. Ovviamente in questo modo le funzioni che possono
%% essere richiamate sono limitate a quelle utilizzate dal
%% programma. Un'altra tecnica che può essere utilizzata viene chiamata
%% \emph{GOT Patching}. La posizione della got table è presente in
%% memoria ad un indirizzo noto. Una volta che la entry nella got
%% relativa alla chiamata di una funzione viene sostituita dal dynamic
%% linker con l'indirizzo reale della funzione si può cercare una
%% sequenza di gadgets per aggiungere l'offset relativo tra quella
%% funzione e la funzione che voglio chiamare. In questo modo si può
%% ritornare nella plt, ma invece della funzione si ritornera alla
%% funzione voluta. Una tecnica per mitigare questo tipo di attacco è
%% quella di effettuare tutte le relocazioni al momento del caricamento
%% dell'eseguibile, e dopo di che rendendo la GOT table
%% read-only. Tuttavia è possibile ritrovare una sequenza di
%% gadget\cite{Sachman} che ci permetta di leggere quest'indirizzo,
%% aggiungere il nostro offset e saltare all'indirizzo calcolato.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "tesi"
%%% End: 
